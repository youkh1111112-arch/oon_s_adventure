<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>JumpKing-like Prototype (Charge Jump)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f19; overflow:hidden; }
    #wrap { position:relative; width:100%; height:100%; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }
    .hud{
      position:absolute; left:12px; top:10px; color:#dbe3ff;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity:.92; user-select:none; pointer-events:none;
      white-space:pre;
    }
    .hint{
      position:absolute; left:12px; bottom:10px; color:#b9c6ff;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity:.8; user-select:none; pointer-events:none;
    }
    .overlay{
      position:absolute; inset:0; display:grid; place-items:center;
      background:rgba(6,10,20,.62);
      opacity:0; pointer-events:none;
      transition:opacity .15s ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }
    .panel{
      text-align:center; color:#f4f7ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .panel h2{
      margin:0 0 12px; font-size:44px; letter-spacing:.06em; font-weight:800;
    }
    .restart-btn{
      border:1px solid #5f84ff; background:#1d2c62; color:#e9f1ff;
      font:600 15px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding:11px 18px; border-radius:10px; cursor:pointer;
    }
    .restart-btn:hover{ background:#24397e; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div class="hud" id="hud"></div>
  <div class="hint">캐릭터 위에서 드래그(아래로 당길수록 강함) → 손 떼면 점프. 완전 정지해야 조작 가능.</div>
  <div id="gameOverOverlay" class="overlay">
    <div class="panel">
      <h2>GAME OVER</h2>
      <button id="restartBtn" class="restart-btn" type="button">Restart</button>
    </div>
  </div>
</div>
<div id="leaderboard" style="position:fixed; top:16px; right:16px; width:240px; padding:12px; background:rgba(0,0,0,.6); color:#fff; font-family:system-ui; border-radius:12px;">
  <div style="font-weight:700; margin-bottom:8px;">TOP 10</div>
  <ol id="leaderboardList" style="margin:0; padding-left:18px;"></ol>
</div>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hud = document.getElementById('hud');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const restartBtn = document.getElementById('restartBtn');

  function DPR(){ return Math.max(1, Math.min(2, window.devicePixelRatio || 1)); }
  function resize(){
    const dpr = DPR();
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ===== Tuning =====
  const GRAVITY = 2200;
  const AIR_DAMP = 0.995;
  const GROUND_DAMP = 0.55;
  const STATIC_VX_EPS = 12;
  const STATIC_VY_EPS = 12;

  const MAX_PULL = 160;
  const MAX_JUMP_VY = 980;
  const MAX_JUMP_VX = 520;
  const MIN_PULL_TO_JUMP = 18;
  const MOMENTUM_MIN_POWER = 0.68;
  const MOMENTUM_IMPACT_SPEED = 260;
  const PLAYER_SPRITE_KIND = 'cat'; // 'cat' | 'dog'
  const FIXED_SPRITE_SRC = 'oon_02_sit.png';
  const IDLE_BOB_AMPLITUDE = 0.9;
  const IDLE_BOB_SPEED = 0.0046;
  const PLAYER_W = 42;
  const PLAYER_H = 56;
  const INPUT_HIT_PAD = 8;
  const JUMP_LEG_STRETCH_MS = 420;
  const JUMP_LEG_STRETCH_MAX = 19;

  const BOTTOM_OUT_MARGIN = 0;
  const SPAWN_Y = 560 - PLAYER_H;
  const PLAYFIELD_TARGET_W = 640;
  const PLAYFIELD_MIN_W = 320;
  const PLAYFIELD_SIDE_MARGIN = 24;
  const START_PLATFORM_W = 180;
  const GROUND_PAD = 260;
  const ITEM_BOB_AMP = 2.6;
  const ITEM_BOB_SPEED = 0.0048;
  const APPLE_BUFF_MS = 10000;
  const BLUE_WEAK_MS = 10000;
  const BLUE_JUMP_SCALE = 1.45;
  const APPLE_BREAK_IMPACT = 170;

  // ===== World =====
  const player = {
    x: 0, y: SPAWN_Y, w: PLAYER_W, h: PLAYER_H,
    vx: 0, vy: 0,
    onGround: false,
    groundPlatform: null
  };
  const cam = { y: 0 };
  let isGameOver = false;
  let frozenElapsedSec = null;
  const residualMomentum = { dirX: 0, dirY: -1, strength: 0 };
  let playerFacing = 1; // 1:right, -1:left
  let jumpStretchUntil = 0;
  let rankSubmittedThisRound = false;
  let appleBuffUntil = 0;
  let blueWeakUntil = 0;
  let pickupPulseUntil = 0;
  const debrisParticles = [];
  const breakCrackFx = [];
  const spriteFxCanvas = document.createElement('canvas');
  const spriteFxCtx = spriteFxCanvas.getContext('2d');

  function isFullyStopped(){
    return player.onGround && Math.abs(player.vx) < STATIC_VX_EPS && Math.abs(player.vy) < STATIC_VY_EPS;
  }

  function isIdleAnimating(){
    return !isGameOver
      && !input.aiming
      && player.onGround
      && Math.abs(player.vx) < 10
      && Math.abs(player.vy) < 10;
  }

  // ===== Platform Generation =====
  let WORLD_MIN_X = 0;
  let WORLD_MAX_X = 0;
  const platforms = [];
  let nextPlatformY = 560;
  let lastPlatformX = 120;
  let mainPlatformCount = 0;
  let lastMainSide = 0;

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rand(min, max){ return min + Math.random() * (max - min); }
  function lerp(a,b,t){ return a + (b - a) * t; }
  function worldCenterX(){ return (WORLD_MIN_X + WORLD_MAX_X) * 0.5; }

  function updateWorldBounds(){
    const W = canvas.clientWidth;
    const playW = Math.min(PLAYFIELD_TARGET_W, Math.max(PLAYFIELD_MIN_W, W - PLAYFIELD_SIDE_MARGIN * 2));
    WORLD_MIN_X = (W - playW) * 0.5;
    WORLD_MAX_X = WORLD_MIN_X + playW;
  }

  function seedBasePlatforms(){
    const playW = WORLD_MAX_X - WORLD_MIN_X;
    const startW = START_PLATFORM_W;
    const startX = clamp(worldCenterX() - startW * 0.5, WORLD_MIN_X + 24, WORLD_MAX_X - startW - 24);

    platforms.length = 0;
    platforms.push(
      { x: WORLD_MIN_X - GROUND_PAD, y: 640, w: playW + GROUND_PAD * 2, h: 50, keep: true, crumble: false, standTime: 0, broken: false },
      { x: startX, y: 560, w: startW, h: 16, keep: true, crumble: false, standTime: 0, broken: false }
    );

    nextPlatformY = 560;
    lastPlatformX = startX;
    mainPlatformCount = 0;
    lastMainSide = 0;
    player.x = startX + (startW - player.w) * 0.5;
    player.y = SPAWN_Y;
  }

  function spawnMinX(){ return WORLD_MIN_X - GROUND_PAD + 14; }
  function spawnMaxX(width){ return WORLD_MAX_X + GROUND_PAD - width - 14; }

  function makePlatform(x, y, w, h, opts = {}){
    return {
      x, y, w, h,
      keep: !!opts.keep,
      crumble: !!opts.crumble,
      standTime: 0,
      broken: false,
      item: null
    };
  }

  function overlapsAnyPlatform(candidate, padding = 6){
    for (const pl of platforms){
      if (pl.broken) continue;
      if (
        candidate.x < pl.x + pl.w + padding &&
        candidate.x + candidate.w > pl.x - padding &&
        candidate.y < pl.y + pl.h + padding &&
        candidate.y + candidate.h > pl.y - padding
      ) return true;
    }
    return false;
  }

  function spawnMainPlatform(y){
    const center = worldCenterX();
    const climb = Math.max(0, SPAWN_Y - y);
    const difficulty = clamp(climb / 4200, 0, 1);

    let w;
    const bucket = Math.random();
    if (bucket < 0.24) w = rand(lerp(180, 130, difficulty), lerp(250, 190, difficulty)); // wide
    else if (bucket < 0.74) w = rand(lerp(130, 92, difficulty), lerp(185, 140, difficulty)); // mid
    else w = rand(lerp(95, 68, difficulty), lerp(130, 105, difficulty)); // narrow

    const roam = lerp(120, 290, difficulty);
    let x = clamp(
      lastPlatformX + rand(-roam, roam) * 0.62 + (center + rand(-130, 130)) * 0.38 - lastPlatformX * 0.38,
      spawnMinX(),
      spawnMaxX(w)
    );
    if (mainPlatformCount < 6){
      const earlyShift = mainPlatformCount % 2 === 0 ? -1 : 1;
      x = clamp(center + earlyShift * rand(55, 150) - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
    }

    let candidate = makePlatform(x, y, w, 16);
    for (let tries = 0; tries < 12 && overlapsAnyPlatform(candidate, 8); tries++){
      x = clamp(rand(spawnMinX() + 2, spawnMaxX(w) - 2), spawnMinX() + 2, spawnMaxX(w) - 2);
      candidate.x = x;
    }

    lastPlatformX = x;
    lastMainSide = (x + w * 0.5) < center ? -1 : 1;
    mainPlatformCount += 1;
    return candidate;
  }

  function generatePlatformsUpTo(minY){
    while (nextPlatformY > minY){
      const climbNow = Math.max(0, SPAWN_Y - nextPlatformY);
      const difficulty = clamp(climbNow / 4200, 0, 1);
      // 초반은 발판을 촘촘하게 배치해 난이도를 낮춘다.
      const earlyDense = clamp((8 - mainPlatformCount) / 8, 0, 1);
      const minGap = lerp(88, 122, difficulty) - earlyDense * 36;
      const maxGap = lerp(142, 220, difficulty) - earlyDense * 58;
      const gap = rand(Math.max(52, minGap), Math.max(78, maxGap));
      nextPlatformY -= gap;

      const main = spawnMainPlatform(nextPlatformY);
      if (!main.keep && mainPlatformCount > 7){
        const crumbleChance = lerp(0.11, 0.23, difficulty);
        if (Math.random() < crumbleChance) main.crumble = true;
      }
      maybeAssignItem(main, difficulty);
      platforms.push(main);

      // 초반은 보조 발판도 조금 더 자주 생성
      const subChance = clamp(lerp(0.30, 0.08, difficulty) + earlyDense * 0.24, 0.08, 0.62);
      if (Math.random() < subChance){
        const w = rand(lerp(96, 70, difficulty), lerp(130, 105, difficulty));
        const y = nextPlatformY + rand(-18, 18);
        let x = rand(spawnMinX() + 2, spawnMaxX(w) - 2);
        const mainCenter = main.x + main.w * 0.5;
        const subCenter = x + w * 0.5;
        if (Math.abs(subCenter - mainCenter) < 200){
          x = subCenter < mainCenter
            ? clamp(main.x - rand(240, 340), spawnMinX() + 2, spawnMaxX(w) - 2)
            : clamp(main.x + rand(240, 340), spawnMinX() + 2, spawnMaxX(w) - 2);
        }
        const sub = makePlatform(x, y, w, 14, { crumble: Math.random() < 0.34 && mainPlatformCount > 7 });
        let placeable = !overlapsAnyPlatform(sub, 8);
        for (let tries = 0; tries < 10 && !placeable; tries++){
          sub.x = rand(spawnMinX() + 2, spawnMaxX(sub.w) - 2);
          placeable = !overlapsAnyPlatform(sub, 8);
        }
        if (placeable){
          maybeAssignItem(sub, difficulty);
          platforms.push(sub);
        }
      }
    }
  }

  function cleanupPlatforms(viewH){
    const cutoffY = cam.y + viewH + 1000;
    for (let i = platforms.length - 1; i >= 0; i--){
      const pl = platforms[i];
      if (pl.keep) continue;
      if (pl.broken){
        platforms.splice(i, 1);
        continue;
      }
      if (pl.y > cutoffY) platforms.splice(i, 1);
    }
  }

  function updateCrumblePlatforms(dt){
    const gp = player.onGround ? player.groundPlatform : null;
    for (const pl of platforms){
      if (!pl.crumble || pl.broken) continue;
      if (pl === gp){
        pl.standTime += dt;
        if (pl.standTime >= 3){
          shatterPlatform(pl);
          player.onGround = false;
          player.groundPlatform = null;
        }
      } else {
        pl.standTime = Math.max(0, pl.standTime - dt * 1.7);
      }
    }
  }

  function isAppleBuffActive(now = performance.now()){
    return now < appleBuffUntil;
  }

  function isBlueWeakActive(now = performance.now()){
    return now < blueWeakUntil;
  }

  function maybeAssignItem(pl, difficulty){
    if (pl.keep || pl.broken) return;
    // 초반 5~6개 메인 발판 구간에서는 아이템 비활성화
    if (mainPlatformCount <= 6) return;
    const chance = lerp(0.38, 0.28, difficulty);
    if (Math.random() > chance) return;
    const type = Math.random() < 0.5 ? 'apple' : 'blueberry';
    pl.item = { type, phase: rand(0, Math.PI * 2) };
  }

  function spawnPickupFx(x, y, color){
    pickupPulseUntil = performance.now() + 260;
    for (let i = 0; i < 10; i++){
      const a = rand(0, Math.PI * 2);
      const s = rand(85, 190);
      debrisParticles.push({
        x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s - 40,
        life: 0.32, maxLife: 0.32, size: rand(2, 4),
        color, grav: 380
      });
    }
  }

  function shatterPlatform(pl){
    if (pl.broken || pl.keep) return;
    pl.broken = true;
    breakCrackFx.push({ x: pl.x, y: pl.y, w: pl.w, h: pl.h, life: 0.16, maxLife: 0.16 });

    const pieces = Math.max(8, Math.floor(pl.w / 16));
    for (let i = 0; i < pieces; i++){
      const px = pl.x + rand(0, pl.w);
      const py = pl.y + rand(1, pl.h - 1);
      const ang = rand(-Math.PI, 0);
      const spd = rand(120, 340);
      debrisParticles.push({
        x: px, y: py,
        vx: Math.cos(ang) * spd + rand(-60, 60),
        vy: Math.sin(ang) * spd - rand(30, 120),
        life: rand(0.42, 0.7), maxLife: 0.7,
        size: rand(2, 6),
        color: pl.crumble ? '#8f6b6e' : '#5169cf',
        grav: 720
      });
    }
  }

  function updateEffects(dt){
    for (let i = debrisParticles.length - 1; i >= 0; i--){
      const p = debrisParticles[i];
      p.vy += (p.grav || 600) * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) debrisParticles.splice(i, 1);
    }
    for (let i = breakCrackFx.length - 1; i >= 0; i--){
      breakCrackFx[i].life -= dt;
      if (breakCrackFx[i].life <= 0) breakCrackFx.splice(i, 1);
    }
  }

  function updateItemCollection(now){
    const pcx = player.x + player.w * 0.5;
    const pcy = player.y + player.h * 0.5;
    for (const pl of platforms){
      if (pl.broken || !pl.item) continue;
      const itemX = pl.x + pl.w * 0.5;
      const itemY = pl.y - 11 + Math.sin(now * ITEM_BOB_SPEED + pl.item.phase) * ITEM_BOB_AMP;
      const d = Math.hypot(itemX - pcx, itemY - pcy);
      if (d > 24) continue;

      if (pl.item.type === 'apple'){
        appleBuffUntil = Math.max(appleBuffUntil, now + APPLE_BUFF_MS);
        spawnPickupFx(itemX, itemY, '#ff6b6b');
      } else {
        blueWeakUntil = Math.max(blueWeakUntil, now + BLUE_WEAK_MS);
        spawnPickupFx(itemX, itemY, '#ffd84d');
      }
      pl.item = null;
    }
  }

  function getPlayerTint(now){
    const appleRem = appleBuffUntil - now;
    const yellowRem = blueWeakUntil - now;
    const rem = Math.max(appleRem, yellowRem);
    if (rem <= 0) return null;

    const color = appleRem >= yellowRem ? '#ff5a66' : '#ffd84d';
    let alpha = 0.36;
    if (rem <= 3000){
      const blinkOn = Math.sin(now * 0.032) > 0;
      alpha = blinkOn ? 0.34 : 0.06;
    }
    return { color, alpha };
  }

  function drawItemVisual(item, sx, sy){
    if (item.type === 'apple'){
      ctx.fillStyle = '#e84d5b';
      ctx.fillRect(sx - 5, sy - 5, 10, 10);
      ctx.fillStyle = '#ff7b86';
      ctx.fillRect(sx - 2, sy - 4, 3, 3);
      ctx.fillStyle = '#603820';
      ctx.fillRect(sx - 1, sy - 8, 2, 3);
      ctx.fillStyle = '#58b46a';
      ctx.fillRect(sx + 1, sy - 9, 3, 2);
    } else {
      ctx.fillStyle = '#f4cd38';
      ctx.fillRect(sx - 4, sy - 4, 8, 8);
      ctx.fillRect(sx - 6, sy - 2, 3, 3);
      ctx.fillRect(sx + 3, sy - 2, 3, 3);
      ctx.fillStyle = '#ffe88f';
      ctx.fillRect(sx - 1, sy - 2, 2, 2);
    }
  }

  function drawDebrisAndCracks(){
    for (const fx of breakCrackFx){
      const a = clamp(fx.life / fx.maxLife, 0, 1);
      const sy = fx.y - cam.y;
      ctx.strokeStyle = `rgba(220, 170, 170, ${0.65 * a})`;
      ctx.lineWidth = 1;
      const c1 = fx.x + fx.w * 0.2;
      const c2 = fx.x + fx.w * 0.46;
      const c3 = fx.x + fx.w * 0.72;
      ctx.beginPath();
      ctx.moveTo(c1, sy + 2); ctx.lineTo(c1 + 8, sy + fx.h - 2);
      ctx.moveTo(c2, sy + 1); ctx.lineTo(c2 - 6, sy + fx.h * 0.6); ctx.lineTo(c2 + 6, sy + fx.h - 2);
      ctx.moveTo(c3, sy + 2); ctx.lineTo(c3 - 7, sy + fx.h - 2);
      ctx.stroke();
    }

    for (const p of debrisParticles){
      const a = clamp(p.life / (p.maxLife || 1), 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color || '#9fb2ff';
      ctx.fillRect(p.x, p.y - cam.y, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  // ===== Score & Time =====
  let startY = player.y;
  let bestY = player.y;
  let t0 = performance.now();

  function score(){
    return Math.max(0, Math.floor((startY - bestY) / 10));
  }
  function elapsedSec(){
    if (frozenElapsedSec !== null) return frozenElapsedSec;
    return Math.floor((performance.now() - t0) / 1000);
  }

  // ===== Input: Charge Jump =====
  const input = {
    aiming: false,
    pid: null,
    startX: 0, startY: 0,
    curX: 0, curY: 0,
    pullX: 0, pullY: 0,
  };

  function pointerPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  const PLAYER_SPRITES = {
    cat: [
      '.1.......1...',
      '11.1...1.11..',
      '1ww1111ww11..',
      '1wwwwwwwww11.',
      '1w2www2www11.',
      '1wwwwwwwww11.',
      '.1w333333w11.',
      '.1wwwwwwww11.',
      '.1ww1ww1ww11.',
      '.1wwwwwwww11.',
      '.1ww4444ww11.',
      '.1www44www11.',
      '..11111111...',
      '..1......1...',
      '.11......11..',
      '.1........1..',
      '11........11.',
    ],
    dog: [
      '.111.....111.',
      '.1bb1...1bb1.',
      '11bbb111bbb11',
      '1bbbbbbbbbbb1',
      '1bb2bbbb2bbb1',
      '1bbbbbbbbbbb1',
      '1bbb33333bbb1',
      '.1bbbbbbbbb1.',
      '.1bbb1b1bbb1.',
      '.1bbbbbbbbb1.',
      '.1bbb444bbb1.',
      '..1bb444bb1..',
      '..111111111..',
      '..1.......1..',
      '.11.......11.',
      '.1.........1.',
      '11.........11',
    ],
  };
  const PLAYER_PALETTES = {
    cat: { '1':'#1f2f66', 'w':'#eaf1ff', '2':'#6b8cff', '3':'#ff9eb4', '4':'#d8e4ff', 'b':'#f5d7af' },
    dog: { '1':'#1f2f66', 'w':'#eaf1ff', '2':'#6b8cff', '3':'#3f3020', '4':'#f3eadb', 'b':'#deb37f' },
  };
  let fixedSpriteImg = null;
  let fixedSpriteTrim = null;
  let fixedSpriteLegColor = '#2a2f40';

  function computeOpaqueBounds(img){
    const iw = img.naturalWidth || img.width || 1;
    const ih = img.naturalHeight || img.height || 1;
    const off = document.createElement('canvas');
    off.width = iw;
    off.height = ih;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.clearRect(0, 0, iw, ih);
    octx.drawImage(img, 0, 0, iw, ih);

    const { data } = octx.getImageData(0, 0, iw, ih);
    let minX = iw, minY = ih, maxX = -1, maxY = -1;
    for (let y = 0; y < ih; y++){
      for (let x = 0; x < iw; x++){
        const a = data[(y * iw + x) * 4 + 3];
        if (a < 10) continue;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
    }

    if (maxX < minX || maxY < minY){
      return { sx: 0, sy: 0, sw: iw, sh: ih };
    }
    return { sx: minX, sy: minY, sw: (maxX - minX + 1), sh: (maxY - minY + 1) };
  }

  function computeRearLegColor(img, trim){
    const iw = img.naturalWidth || img.width || 1;
    const ih = img.naturalHeight || img.height || 1;
    const off = document.createElement('canvas');
    off.width = iw;
    off.height = ih;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.clearRect(0, 0, iw, ih);
    octx.drawImage(img, 0, 0, iw, ih);
    const { data } = octx.getImageData(0, 0, iw, ih);

    const rx0 = Math.floor(trim.sx + trim.sw * 0.00);
    const rx1 = Math.ceil(trim.sx + trim.sw * 0.45);
    const ry0 = Math.floor(trim.sy + trim.sh * 0.55);
    const ry1 = Math.ceil(trim.sy + trim.sh * 1.00);

    let r = 0, g = 0, b = 0, n = 0;
    for (let y = ry0; y < ry1; y++){
      for (let x = rx0; x < rx1; x++){
        const a = data[(y * iw + x) * 4 + 3];
        if (a < 20) continue;
        const j = (y * iw + x) * 4;
        r += data[j];
        g += data[j + 1];
        b += data[j + 2];
        n += 1;
      }
    }
    if (n === 0) return '#2a2f40';
    const rr = Math.round(r / n).toString(16).padStart(2, '0');
    const gg = Math.round(g / n).toString(16).padStart(2, '0');
    const bb = Math.round(b / n).toString(16).padStart(2, '0');
    return `#${rr}${gg}${bb}`;
  }

  function getJumpLegStretch(now){
    if (isGameOver || player.onGround) return 0;
    const launchStretch = clamp((jumpStretchUntil - now) / JUMP_LEG_STRETCH_MS, 0, 1);
    const airStretch = clamp((-player.vy - 40) / 560, 0, 1) * 0.85;
    return Math.max(launchStretch, airStretch);
  }

  function loadFixedSprite(){
    const img = new Image();
    img.onload = () => {
      fixedSpriteImg = img;
      fixedSpriteTrim = computeOpaqueBounds(img);
      fixedSpriteLegColor = computeRearLegColor(img, fixedSpriteTrim);
    };
    img.onerror = () => {
      console.warn(`[jumpking_proto] failed to load fixed sprite: ${FIXED_SPRITE_SRC}`);
    };
    img.src = FIXED_SPRITE_SRC;
  }

  function drawPixelSprite(kind, x, y, facing = 1, tint = null){
    if (fixedSpriteImg){
      const trim = fixedSpriteTrim || {
        sx: 0,
        sy: 0,
        sw: (fixedSpriteImg.naturalWidth || fixedSpriteImg.width || 1),
        sh: (fixedSpriteImg.naturalHeight || fixedSpriteImg.height || 1)
      };
      const scale = Math.min(player.w / trim.sw, player.h / trim.sh);
      const dw = trim.sw * scale;
      const dh = trim.sh * scale;
      const ox = x + (player.w - dw) * 0.5;
      const oy = y + (player.h - dh);
      const stretch = getJumpLegStretch(performance.now());
      const tw = Math.max(1, Math.round(dw));
      const th = Math.max(1, Math.round(dh));

      if (spriteFxCanvas.width !== tw || spriteFxCanvas.height !== th){
        spriteFxCanvas.width = tw;
        spriteFxCanvas.height = th;
      }
      spriteFxCtx.clearRect(0, 0, tw, th);
      spriteFxCtx.imageSmoothingEnabled = false;
      if (facing < 0){
        spriteFxCtx.save();
        spriteFxCtx.translate(tw, 0);
        spriteFxCtx.scale(-1, 1);
        spriteFxCtx.drawImage(fixedSpriteImg, trim.sx, trim.sy, trim.sw, trim.sh, 0, 0, tw, th);
        spriteFxCtx.restore();
      } else {
        spriteFxCtx.drawImage(fixedSpriteImg, trim.sx, trim.sy, trim.sw, trim.sh, 0, 0, tw, th);
      }
      if (tint){
        spriteFxCtx.globalCompositeOperation = 'source-atop';
        spriteFxCtx.globalAlpha = tint.alpha;
        spriteFxCtx.fillStyle = tint.color;
        spriteFxCtx.fillRect(0, 0, tw, th);
        spriteFxCtx.globalCompositeOperation = 'source-over';
        spriteFxCtx.globalAlpha = 1;
      }

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(spriteFxCanvas, ox, oy, dw, dh);

      if (stretch > 0.01){
        const legW = Math.max(2, Math.floor(dw * 0.09));
        const legGap = Math.max(3, Math.floor(dw * 0.12));
        const legX0 = Math.floor(dw * 0.13);
        const legY = Math.floor(dh * 0.74);
        const legH = Math.floor(6 + stretch * JUMP_LEG_STRETCH_MAX);

        ctx.fillStyle = fixedSpriteLegColor;
        if (facing < 0){
          ctx.fillRect(legX0, legY, legW, legH);
          ctx.fillRect(legX0 + legGap, legY + 1, legW, Math.max(3, legH - 1));
        } else {
          ctx.fillRect(ox + legX0, oy + legY, legW, legH);
          ctx.fillRect(ox + legX0 + legGap, oy + legY + 1, legW, Math.max(3, legH - 1));
        }
      }
      ctx.restore();
      return;
    }

    const sprite = PLAYER_SPRITES[kind] || PLAYER_SPRITES.cat;
    const palette = PLAYER_PALETTES[kind] || PLAYER_PALETTES.cat;
    const scale = Math.min(player.w / sprite[0].length, player.h / sprite.length);
    const ox = x + (player.w - sprite[0].length * scale) * 0.5;
    const oy = y + (player.h - sprite.length * scale) * 0.5;

    for (let r = 0; r < sprite.length; r++){
      const row = sprite[r];
      for (let c = 0; c < row.length; c++){
        const ch = row[c];
        if (ch === '.') continue;
        const color = palette[ch];
        if (!color) continue;
        const cc = facing < 0 ? (row.length - 1 - c) : c;
        ctx.fillStyle = color;
        ctx.fillRect(ox + cc * scale, oy + r * scale, scale, scale);
      }
    }
  }

  function playerScreenCenter(){
    return {
      x: player.x + player.w/2,
      y: (player.y - cam.y) + player.h/2
    };
  }

  function hitPlayerScreen(px, py){
    const s = { x: player.x, y: (player.y - cam.y) };
    return px >= s.x - INPUT_HIT_PAD && px <= s.x + player.w + INPUT_HIT_PAD
      && py >= s.y - INPUT_HIT_PAD && py <= s.y + player.h + INPUT_HIT_PAD;
  }

  function beginAim(e){
    if (isGameOver) return;
    if (!isFullyStopped()) return;

    const p = pointerPos(e);
    if (!hitPlayerScreen(p.x, p.y)) return;

    const c = playerScreenCenter();

    input.aiming = true;
    input.pid = e.pointerId;
    input.startX = c.x;
    input.startY = c.y;
    input.curX = p.x;
    input.curY = p.y;
    input.pullX = 0;
    input.pullY = 0;

    canvas.setPointerCapture?.(e.pointerId);
  }

  function moveAim(e){
    if (isGameOver) return;
    if (!input.aiming || e.pointerId !== input.pid) return;

    const p = pointerPos(e);
    input.curX = p.x;
    input.curY = p.y;

    let dx = input.curX - input.startX;
    let dy = input.curY - input.startY;
    dy = Math.max(0, dy);

    dx = clamp(dx, -MAX_PULL, MAX_PULL);
    dy = clamp(dy, 0, MAX_PULL);

    const dist = Math.hypot(dx, dy);
    if (dist > MAX_PULL){
      const s = MAX_PULL / dist;
      dx *= s;
      dy *= s;
    }

    input.pullX = dx;
    input.pullY = dy;
  }

  function endAim(e){
    if (isGameOver) return;
    if (!input.aiming || e.pointerId !== input.pid) return;

    const pullLen = Math.hypot(input.pullX, input.pullY);

    input.aiming = false;
    input.pid = null;

    if (pullLen < MIN_PULL_TO_JUMP) return;

    const power = clamp(pullLen / MAX_PULL, 0, 1);
    const now = performance.now();
    const jumpScale = isBlueWeakActive(now) ? BLUE_JUMP_SCALE : 1;
    const vy = -power * MAX_JUMP_VY * jumpScale;
    const vx = (input.pullX / MAX_PULL) * MAX_JUMP_VX * power * jumpScale;

    player.vx = vx;
    player.vy = vy;
    player.onGround = false;
    jumpStretchUntil = now + JUMP_LEG_STRETCH_MS;
    if (Math.abs(vx) > 8) playerFacing = Math.sign(vx);

    const n = Math.hypot(vx, vy) || 1;
    residualMomentum.dirX = vx / n;
    residualMomentum.dirY = vy / n;
    residualMomentum.strength = power;
  }

  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); beginAim(e); }, { passive:false });
  canvas.addEventListener('pointermove', (e)=>{ if(input.aiming) e.preventDefault(); moveAim(e); }, { passive:false });
  canvas.addEventListener('pointerup',   (e)=>{ e.preventDefault(); endAim(e); }, { passive:false });
  canvas.addEventListener('pointercancel',(e)=>{ endAim(e); }, { passive:true });

  // ===== Collision =====
  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function applyCollisionMomentum(blockAxis, impactSpeed){
    if (residualMomentum.strength < MOMENTUM_MIN_POWER) return false;
    if (impactSpeed < MOMENTUM_IMPACT_SPEED) return false;

    const carry = clamp((residualMomentum.strength - MOMENTUM_MIN_POWER) / (1 - MOMENTUM_MIN_POWER), 0, 1);

    if (blockAxis === 'x'){
      const tangentDir = residualMomentum.dirY !== 0
        ? Math.sign(residualMomentum.dirY)
        : (player.vy === 0 ? -1 : Math.sign(player.vy));
      const tangentGain = Math.max(80, impactSpeed * (0.16 + 0.26 * carry));
      player.vy += tangentDir * tangentGain;
      player.vx = -Math.sign(player.vx || residualMomentum.dirX || 1) * Math.min(90, impactSpeed * 0.14);
    } else {
      const tangentDir = residualMomentum.dirX !== 0
        ? Math.sign(residualMomentum.dirX)
        : (player.vx === 0 ? 0 : Math.sign(player.vx));
      const tangentGain = Math.max(70, impactSpeed * (0.20 + 0.34 * carry));
      player.vx += tangentDir * tangentGain;
      player.vy = Math.max(player.vy, 40);
    }

    residualMomentum.strength *= 0.72;
    return true;
  }

  function resolve(dt){
    player.onGround = false;
    player.groundPlatform = null;
    const prevY = player.y;

    // X move
    player.x += player.vx * dt;
    if (Math.abs(player.vx) > 18) playerFacing = Math.sign(player.vx);
    for (const pl of platforms){
      if (pl.broken) continue;
      if (!aabb(player.x, player.y, player.w, player.h, pl.x, pl.y, pl.w, pl.h)) continue;

      const impactX = Math.abs(player.vx);
      if (isAppleBuffActive() && !pl.keep && impactX > APPLE_BREAK_IMPACT){
        shatterPlatform(pl);
        continue;
      }

      // 코너 스침(세로 겹침이 매우 얕은 경우)은 옆벽 충돌로 처리하지 않는다.
      // 이걸 허용하면 "보이지 않는 벽"처럼 옆으로 밀려 착지를 놓치는 현상이 줄어든다.
      const pTop = player.y;
      const pBottom = player.y + player.h;
      const overlapY = Math.min(pBottom, pl.y + pl.h) - Math.max(pTop, pl.y);
      if (overlapY <= 6) continue;

      // 발판 윗면 착지 직전 상황은 X보다 Y 처리(착지)를 우선한다.
      const nextBottom = (player.y + player.vy * dt) + player.h;
      if (player.vy >= 0 && pBottom <= pl.y + 8 && nextBottom >= pl.y - 2) continue;

      if (player.vx > 0) player.x = pl.x - player.w;
      else if (player.vx < 0) player.x = pl.x + pl.w;
      if (!applyCollisionMomentum('x', impactX)) player.vx = 0;
    }

    // Y move
    player.y += player.vy * dt;
    for (const pl of platforms){
      if (pl.broken) continue;
      const overlapsX = player.x < pl.x + pl.w && player.x + player.w > pl.x;
      if (!overlapsX) continue;

      const prevTop = prevY;
      const prevBottom = prevY + player.h;
      const curTop = player.y;
      const curBottom = player.y + player.h;

      if (player.vy > 0){
        if (prevBottom <= pl.y && curBottom >= pl.y){
          player.y = pl.y - player.h;
          player.vy = 0;
          player.onGround = true;
          player.groundPlatform = pl;
          break;
        }
      } else if (player.vy < 0){
        const plBottom = pl.y + pl.h;
        if (prevTop >= plBottom && curTop <= plBottom){
          const impactY = Math.abs(player.vy);
          if (isAppleBuffActive() && !pl.keep && impactY > APPLE_BREAK_IMPACT){
            shatterPlatform(pl);
            continue;
          }
          player.y = plBottom;
          if (!applyCollisionMomentum('y', impactY)) player.vy = 0;
          break;
        }
      }

      if (!aabb(player.x, player.y, player.w, player.h, pl.x, pl.y, pl.w, pl.h)) continue;
      if (player.vy >= 0){
        player.y = pl.y - player.h;
        player.vy = 0;
        player.onGround = true;
        player.groundPlatform = pl;
        break;
      } else {
        const impactY = Math.abs(player.vy);
        if (isAppleBuffActive() && !pl.keep && impactY > APPLE_BREAK_IMPACT){
          shatterPlatform(pl);
          continue;
        }
        player.y = pl.y + pl.h;
        if (!applyCollisionMomentum('y', impactY)) player.vy = 0;
        break;
      }
    }

    if (player.onGround){
      player.vx *= GROUND_DAMP;
      if (Math.abs(player.vx) < STATIC_VX_EPS) player.vx = 0;
      if (Math.abs(player.vy) < STATIC_VY_EPS) player.vy = 0;
      residualMomentum.strength *= 0.88;
    } else {
      residualMomentum.strength *= 0.996;
    }
    if (residualMomentum.strength < 0.02){
      residualMomentum.strength = 0;
    }
  }

  function setGameOver(v){
    isGameOver = v;
    gameOverOverlay.classList.toggle('show', v);
    if (v){
      if (frozenElapsedSec === null) frozenElapsedSec = Math.floor((performance.now() - t0) / 1000);
      input.aiming = false;
      input.pid = null;
      submitRankOnGameOver();
    } else {
      frozenElapsedSec = null;
    }
  }

  function checkGameOver(){
    const H = canvas.clientHeight;
    const outBelow = (player.y - cam.y) > (H + BOTTOM_OUT_MARGIN);
    if (outBelow) setGameOver(true);
  }

  async function submitRankOnGameOver(){
    if (rankSubmittedThisRound) return;
    rankSubmittedThisRound = true;

    const name = prompt("이름 입력 (12자 이내)");
    if (!name) return;

    const submit = window.leaderboardSubmit;
    if (typeof submit !== 'function'){
      console.warn('leaderboardSubmit is not ready');
      alert("랭킹 모듈이 아직 준비되지 않았어요. URL/KEY 또는 네트워크를 확인해줘.");
      return;
    }

    const res = await submit(name, score());
    if (!res?.ok){
      const msg = typeof res?.error === 'string'
        ? res.error
        : (res?.error?.message || JSON.stringify(res?.error || {}));
      alert(`저장 실패: ${msg}`);
    }
  }

  function resetGame(){
    updateWorldBounds();
    seedBasePlatforms();
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    cam.y = 0;

    generatePlatformsUpTo(player.y - canvas.clientHeight * 2.2);

    startY = player.y;
    bestY = player.y;
    t0 = performance.now();
    frozenElapsedSec = null;

    input.aiming = false;
    input.pid = null;
    residualMomentum.dirX = 0;
    residualMomentum.dirY = -1;
    residualMomentum.strength = 0;
    appleBuffUntil = 0;
    blueWeakUntil = 0;
    pickupPulseUntil = 0;
    debrisParticles.length = 0;
    breakCrackFx.length = 0;
    jumpStretchUntil = 0;
    playerFacing = 1;
    rankSubmittedThisRound = false;
    setGameOver(false);
    if (typeof window.leaderboardRefresh === 'function') window.leaderboardRefresh();
  }

  restartBtn.addEventListener('click', resetGame);
  window.addEventListener('resize', updateWorldBounds, { passive:true });

  // ===== Loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!isGameOver){
      player.vy += GRAVITY * dt;
      player.vx *= AIR_DAMP;
      player.vy *= AIR_DAMP;

      resolve(dt);
      updateCrumblePlatforms(dt);
      updateItemCollection(now);
      updateEffects(dt);

      if (player.y < bestY) bestY = player.y;

      const H = canvas.clientHeight;
      const target = player.y - H * 0.40;
      cam.y = Math.min(cam.y, target);

      generatePlatformsUpTo(cam.y - H * 1.8);
      cleanupPlatforms(H);

      checkGameOver();
    }

    render();
    requestAnimationFrame(tick);
  }

  function render(){
    const W = canvas.clientWidth;
    const H = canvas.clientHeight;
    const now = performance.now();

    ctx.fillStyle = '#0b0f19';
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#2a3a6a';
    for (let i=0;i<70;i++){
      const x = (i*97) % W;
      const y = (i*173) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // playfield boundaries
    ctx.fillStyle = 'rgba(2, 6, 14, 0.45)';
    if (WORLD_MIN_X > 0) ctx.fillRect(0, 0, WORLD_MIN_X, H);
    if (WORLD_MAX_X < W) ctx.fillRect(WORLD_MAX_X, 0, W - WORLD_MAX_X, H);

    for (const pl of platforms){
      if (pl.broken) continue;
      const sy = pl.y - cam.y;
      if (sy > H + 80 || sy + pl.h < -80) continue;

      const crumbleT = pl.crumble ? clamp(pl.standTime / 3, 0, 1) : 0;
      ctx.fillStyle = pl.crumble
        ? (crumbleT > 0.7 ? '#4f2a2f' : '#3a324b')
        : '#1a2550';
      ctx.fillRect(pl.x, sy, pl.w, pl.h);

      ctx.strokeStyle = pl.crumble ? '#8f6b6e' : '#2f46a8';
      ctx.lineWidth = 1;
      ctx.strokeRect(pl.x + 0.5, sy + 0.5, pl.w - 1, pl.h - 1);

      if (pl.crumble){
        // 금 간 블록 표현
        ctx.strokeStyle = crumbleT > 0.7 ? '#d48888' : '#b39aa4';
        ctx.lineWidth = 1;
        const c1 = pl.x + pl.w * 0.22;
        const c2 = pl.x + pl.w * 0.47;
        const c3 = pl.x + pl.w * 0.71;
        ctx.beginPath();
        ctx.moveTo(c1, sy + 2); ctx.lineTo(c1 + 8, sy + pl.h - 2);
        ctx.moveTo(c2, sy + 1); ctx.lineTo(c2 - 6, sy + pl.h * 0.6); ctx.lineTo(c2 + 6, sy + pl.h - 2);
        ctx.moveTo(c3, sy + 2); ctx.lineTo(c3 - 7, sy + pl.h - 2);
        ctx.stroke();
      }

      if (pl.item){
        const itemX = pl.x + pl.w * 0.5;
        const itemY = sy - 11 + Math.sin(now * ITEM_BOB_SPEED + pl.item.phase) * ITEM_BOB_AMP;
        drawItemVisual(pl.item, itemX, itemY);
      }
    }

    drawDebrisAndCracks();

    const idleBob = isIdleAnimating()
      ? Math.sin(performance.now() * IDLE_BOB_SPEED) * IDLE_BOB_AMPLITUDE
      : 0;
    const pickupPulse = clamp((pickupPulseUntil - now) / 260, 0, 1);
    const py = player.y - cam.y + idleBob - pickupPulse * 1.2;
    if (pickupPulse > 0){
      const cx = player.x + player.w * 0.5;
      const cy = py + player.h * 0.45;
      ctx.strokeStyle = `rgba(255, 245, 168, ${0.35 * pickupPulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, 16 + (1 - pickupPulse) * 8, 0, Math.PI * 2);
      ctx.stroke();
    }
    const playerTint = getPlayerTint(now);
    drawPixelSprite(PLAYER_SPRITE_KIND, player.x, py, playerFacing, playerTint);

    if (input.aiming){
      const sx = input.startX;
      const sy = input.startY;

      ctx.lineWidth = 4;
      ctx.strokeStyle = '#6aa2ff';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + input.pullX, sy + input.pullY);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#9ad1ff';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - input.pullX, sy - input.pullY);
      ctx.stroke();

      const power = clamp(Math.hypot(input.pullX, input.pullY) / MAX_PULL, 0, 1);
      ctx.fillStyle = '#6aa2ff';
      ctx.fillRect(12, 44, 140 * power, 8);
      ctx.strokeStyle = '#2f46a8';
      ctx.strokeRect(12.5, 44.5, 140, 8);
    }

    const t = elapsedSec();
    const mm = String(Math.floor(t/60)).padStart(2,'0');
    const ss = String(t%60).padStart(2,'0');

    hud.textContent =
`SCORE  ${score()}
TIME   ${mm}:${ss}
STATE  ${isGameOver ? 'GAME OVER' : (isFullyStopped() ? 'READY' : (player.onGround ? 'GROUND' : 'AIR'))}
POS    (${player.x.toFixed(0)}, ${player.y.toFixed(0)})`;
  }

  updateWorldBounds();
  seedBasePlatforms();
  loadFixedSprite();
  generatePlatformsUpTo(player.y - canvas.clientHeight * 2.2);
  requestAnimationFrame(tick);
})();
</script>
<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  const SUPABASE_URL = "https://bemuemmhdurymuqkvfzr.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_zQDh_XUbi9EdWsWk64faRQ_OUp9bNqb";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const listEl = document.getElementById("leaderboardList");

  function esc(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  async function fetchTop10(){
    const { data, error } = await supabase
      .from("leaderboard")
      .select("name,score,created_at")
      .order("score", { ascending: false })
      .order("created_at", { ascending: true })
      .limit(10);

    if (error) {
      console.error("fetchTop10 error:", error);
      return;
    }

    listEl.innerHTML = data.map(row =>
      `<li>${esc(row.name)} — <b>${row.score}</b></li>`
    ).join("");
  }

  // 게임 시작 시 1회 로드
  fetchTop10();

  // 아래 함수들을 window에 달아두면, 기존 게임 코드에서 호출하기 편함
  window.leaderboardSubmit = async function(name, score){
    const cleanedName = String(name).trim().slice(0, 12);
    const cleanedScore = Math.max(0, Math.floor(Number(score) || 0));

    if (!cleanedName) return { ok:false, error:"name empty" };

    const { error } = await supabase
      .from("leaderboard")
      .insert([{ name: cleanedName, score: cleanedScore }]);

    if (error) {
      console.error("insert error:", error);
      return { ok:false, error: error.message || String(error) };
    }

    await fetchTop10();
    return { ok:true };
  };

  window.leaderboardRefresh = fetchTop10;
</script>
</body>
</html>
