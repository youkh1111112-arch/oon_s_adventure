<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>JumpKing-like Prototype (Charge Jump)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#0b0f19; overflow:hidden; }
    #wrap { position:fixed; inset:0; overflow:hidden; background:#0b0f19; }
    canvas {
      position:fixed; left:0; top:0; display:block;
      width:100vw; height:100vh;
      background:#0b0f19;
      touch-action:none;
    }
    .hud{
      position:absolute; left:12px; top:10px; color:#dbe3ff;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity:.92; user-select:none; pointer-events:none;
      white-space:pre;
    }
    .hint{
      position:absolute; left:12px; bottom:10px; color:#b9c6ff;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity:.8; user-select:none; pointer-events:none;
    }
    .overlay{
      position:absolute; inset:0; display:grid; place-items:center;
      background:rgba(6,10,20,.62);
      opacity:1; pointer-events:auto;
      display:none;
    }
    .overlay.show{ display:grid; }
    .panel{
      text-align:center; color:#f4f7ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .panel h2{
      margin:0 0 12px; font-size:44px; letter-spacing:.06em; font-weight:800;
    }
    .restart-btn{
      border:1px solid #5f84ff; background:#1d2c62; color:#e9f1ff;
      font:600 15px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding:11px 18px; border-radius:10px; cursor:pointer;
    }
    .restart-btn:hover{ background:#24397e; }
    body.force-mobile #leaderboard{
      top:10px !important;
      right:10px !important;
      width:170px !important;
      padding:8px !important;
      border-radius:10px !important;
      font-size:12px !important;
    }
    body.force-mobile #leaderboardList{
      padding-left:14px !important;
      font-size:12px !important;
    }
    #storyToast{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%) scale(0.98);
      max-width:min(88vw, 700px);
      padding:14px 22px;
      border-radius:14px;
      color:#f7fbff;
      font:700 clamp(22px, 4.4vw, 42px)/1.22 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      letter-spacing:-0.01em;
      text-align:center;
      white-space:normal;
      background:rgba(10, 17, 32, 0.52);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      text-shadow:0 2px 10px rgba(5, 8, 15, 0.7);
      box-shadow:0 10px 34px rgba(0, 0, 0, 0.28);
      opacity:0;
      pointer-events:none;
      z-index:30;
      transition:opacity 0.2s ease-out, transform 0.2s ease-out;
    }
    #storyToast.show{
      opacity:1;
      transform:translate(-50%, -50%) scale(1);
    }
    #storyToast.hide{
      opacity:0;
      transform:translate(-50%, -50%) scale(1.01);
      transition:opacity 0.4s ease-in, transform 0.4s ease-in;
    }
    @media (max-width: 768px){
      #leaderboard{
        top:10px !important;
        right:10px !important;
        width:170px !important;
        padding:8px !important;
        border-radius:10px !important;
        font-size:12px !important;
      }
      #leaderboardList{
        padding-left:14px !important;
        font-size:12px !important;
      }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div class="hud" id="hud"></div>
  <div class="hint">캐릭터 위에서 드래그(아래로 당길수록 강함) → 손 떼면 점프. 완전 정지해야 조작 가능.</div>
  <div id="gameOverOverlay" class="overlay">
    <div class="panel">
      <h2>GAME OVER</h2>
      <button id="restartBtn" class="restart-btn" type="button">Restart</button>
    </div>
  </div>
</div>
<div id="leaderboard" style="position:fixed; top:16px; right:16px; width:240px; padding:12px; background:rgba(0,0,0,.6); color:#fff; font-family:system-ui; border-radius:12px;">
  <div style="font-weight:700; margin-bottom:8px;">TOP 5</div>
  <ol id="leaderboardList" style="margin:0; padding-left:18px;"></ol>
</div>
<div id="storyToast" aria-live="polite"></div>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hud = document.getElementById('hud');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const storyToastEl = document.getElementById('storyToast');

  function DPR(){ return Math.max(1, Math.min(2, window.devicePixelRatio || 1)); }
  let viewportW = 0;
  let viewportH = 0;
  function resize(){
    const dpr = DPR();
    viewportW = Math.round(window.innerWidth);
    viewportH = Math.round(window.innerHeight);
    canvas.width = Math.round(viewportW * dpr);
    canvas.height = Math.round(viewportH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ===== Tuning =====
  const GRAVITY = 2200;
  const AIR_DAMP = 0.995;
  const GROUND_DAMP = 0.55;
  const STATIC_VX_EPS = 12;
  const STATIC_VY_EPS = 12;

  const MAX_PULL = 160;
  const MAX_JUMP_VY = 980;
  const MAX_JUMP_VX = 520;
  const MIN_PULL_TO_JUMP = 18;
  const MOMENTUM_MIN_POWER = 0.68;
  const MOMENTUM_IMPACT_SPEED = 260;
  const PLAYER_SPRITE_KIND = 'cat'; // 'cat' | 'dog'
  const FIXED_SPRITE_SRC = 'oon_02_sit.png';
  const IDLE_BOB_AMPLITUDE = 0.9;
  const IDLE_BOB_SPEED = 0.0046;
  const PLAYER_W = 42;
  const PLAYER_H = 56;
  const INPUT_HIT_PAD = 8;
  const JUMP_LEG_STRETCH_MS = 420;
  const JUMP_LEG_STRETCH_MAX = 19;

  const BOTTOM_OUT_MARGIN = 0;
  const SPAWN_Y = 560 - PLAYER_H;
  const PLAYFIELD_TARGET_W = 640;
  const PLAYFIELD_MIN_W = 320;
  const PLAYFIELD_SIDE_MARGIN = 24;
  const START_PLATFORM_W = 180;
  const GROUND_PAD = 260;
  const PLATFORM_SPAWN_SIDE_BLEED = 36;
  const ITEM_BOB_AMP = 2.6;
  const ITEM_BOB_SPEED = 0.0048;
  const APPLE_BUFF_MS = 10000;
  const BLUE_WEAK_MS = 10000;
  const BLUE_JUMP_SCALE = 1.45;
  const APPLE_BREAK_IMPACT = 170;
  const REACH_MAX_DY = 205;
  const CRUMBLE_BREAK_SEC = 1.7;
  const AUTO_DECAY_START_SEC = 2.2;
  const AUTO_DECAY_BREAK_SEC = 5.2;
  const SEA_BUBBLE_SPAWN_PER_SEC = 8.5;
  const SEA_BUBBLE_MAX = 52;
  const FISH_TARGET_H = 86;
  const FISH_FALLBACK_ASPECT = 1.5;
  const EEL_SPRITE_SRC = 'eel_3.png';
  const FISH_MIN_SPAWN_OFFSET_Y = 420;
  const FISH_SPAWN_GAP_MIN = 200;
  const FISH_SPAWN_GAP_MAX = 290;
  const FISH_HIT_COOLDOWN_MS = 900;

  // ===== World =====
  const player = {
    x: 0, y: SPAWN_Y, w: PLAYER_W, h: PLAYER_H,
    vx: 0, vy: 0,
    onGround: false,
    groundPlatform: null
  };
  const cam = { y: 0 };
  let isGameOver = false;
  let frozenElapsedSec = null;
  const residualMomentum = { dirX: 0, dirY: -1, strength: 0 };
  let playerFacing = 1; // 1:right, -1:left
  let jumpStretchUntil = 0;
  let rankSubmittedThisRound = false;
  let appleBuffUntil = 0;
  let blueWeakUntil = 0;
  let pickupPulseUntil = 0;
  let pickupText = '';
  let pickupTextUntil = 0;
  let storyShown = false;
  const debrisParticles = [];
  const breakCrackFx = [];
  const seaBubbles = [];
  const deepSeaFish = [];
  const spriteFxCanvas = document.createElement('canvas');
  const spriteFxCtx = spriteFxCanvas.getContext('2d');
  let eelSpriteImg = null;
  const STORY_TOAST_TOTAL_MS = 1600;
  const STORY_TOAST_HIDE_AT_MS = 1200;
  let storyToastHideTimer = 0;
  let storyToastEndTimer = 0;
  let seaBubbleSpawnAcc = 0;
  let nextFishSpawnY = SPAWN_Y - FISH_MIN_SPAWN_OFFSET_Y;
  let fishHitCooldownUntil = 0;

  function clearStoryToastTimers(){
    if (storyToastHideTimer){
      clearTimeout(storyToastHideTimer);
      storyToastHideTimer = 0;
    }
    if (storyToastEndTimer){
      clearTimeout(storyToastEndTimer);
      storyToastEndTimer = 0;
    }
  }

  function showStoryToast(text){
    clearStoryToastTimers();
    storyToastEl.textContent = text;
    storyToastEl.classList.remove('show', 'hide');
    // Restart CSS transition sequence for repeated calls.
    void storyToastEl.offsetWidth;
    storyToastEl.classList.add('show');

    storyToastHideTimer = setTimeout(() => {
      storyToastEl.classList.remove('show');
      storyToastEl.classList.add('hide');
    }, STORY_TOAST_HIDE_AT_MS);

    storyToastEndTimer = setTimeout(() => {
      storyToastEl.classList.remove('hide');
    }, STORY_TOAST_TOTAL_MS);
  }

  function isFullyStopped(){
    return player.onGround && Math.abs(player.vx) < STATIC_VX_EPS && Math.abs(player.vy) < STATIC_VY_EPS;
  }

  function isIdleAnimating(){
    return !isGameOver
      && !input.aiming
      && player.onGround
      && Math.abs(player.vx) < 10
      && Math.abs(player.vy) < 10;
  }

  // ===== Platform Generation =====
  let WORLD_MIN_X = 0;
  let WORLD_MAX_X = 0;
  const platforms = [];
  let nextPlatformY = 560;
  let lastPlatformX = 120;
  let mainPlatformCount = 0;
  let lastMainSide = 0;
  let lastMainPlatform = null;
  let earlyPreferredSide = 1;
  const MAIN_MIN_DY = 90;
  const MAIN_MAX_DY = 160;
  const MAIN_MIN_SHIFT = 64;
  const MAIN_ROUTE_RETRY = 28;
  const MAIN_ROUTE_DEBUG = false;
  const MAIN_DY_DEBUG = false;
  const FORCE_MOBILE_VIEW = true;
  const MOBILE_MAIN_MIN_DY_HARD = 88;
  const MOBILE_MAIN_REROLL_MAX = 20;
  const MOBILE_MAIN_MAX_DY_SAFE = 150;
  const MOBILE_MAIN_MIN_SHIFT_HARD = 96;
  const DESKTOP_MAIN_MIN_SHIFT_HARD = 72;
  const MOBILE_MAIN_MIN_EDGE_GAP = 30;
  const DESKTOP_MAIN_MIN_EDGE_GAP = 18;
  const MOBILE_MAIN_MAX_W_SCREEN_RATIO = 0.56;
  const DESKTOP_MAIN_MAX_W_SCREEN_RATIO = 0.62;
  const MOBILE_SUB_MAX_W_SCREEN_RATIO = 0.52;
  const DESKTOP_SUB_MAX_W_SCREEN_RATIO = 0.58;
  const RANDOM_PLATFORM_MAX_W_SCREEN_RATIO = 0.52;
  const MOBILE_RANDOM_PLATFORM_MAX_W_SCREEN_RATIO = 0.50;
  const SMALL_ANCHOR_W = 132;
  const SMALL_ANCHOR_NEARBY_Y_BAND = 66;
  const SMALL_ANCHOR_WIDE_BLOCK_RATIO = 0.44;
  const BLOCKING_CEILING_DY = 120;
  const BLOCKING_CEILING_OVERLAP_RATIO = 0.58;
  const MOBILE_SUB_ROLLS_MAX = 1;
  const MOBILE_SUB_BAND_DY = 54;
  const MOBILE_SUB_BAND_MAX = 2;
  const MOBILE_ROUTE_BLOCK_DY_MIN = 26;
  const MOBILE_ROUTE_BLOCK_DY_MAX = 170;
  const MOBILE_ROUTE_BLOCK_OVERLAP_RATIO = 0.46;
  const CEILING_TRAP_BLOCKED_RATIO = 0.85;
  const CEILING_TRAP_MIN_FREE_W = 70;
  const CEILING_TRAP_NEAR_ANCHOR = 120;
  const CEILING_TRAP_REROLL_MAX = 30;
  const mainRouteRecent = [];
  const mainDyRecent = { mobile: [], desktop: [] };

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rand(min, max){ return min + Math.random() * (max - min); }
  function lerp(a,b,t){ return a + (b - a) * t; }
  function worldCenterX(){ return (WORLD_MIN_X + WORLD_MAX_X) * 0.5; }
  function isMobileMode(){
    return FORCE_MOBILE_VIEW || matchMedia("(max-width: 900px)").matches || /iPhone|Android/i.test(navigator.userAgent);
  }
  if (FORCE_MOBILE_VIEW) document.body.classList.add('force-mobile');
  function updateWorldBounds(){
    const W = viewportW || Math.round(window.innerWidth);
    // 중앙 고정 플레이필드를 없애고 화면 전체를 플레이 영역으로 사용
    // (가운데 띠처럼 보이는 구분감을 제거)
    WORLD_MIN_X = 0;
    WORLD_MAX_X = W;
  }

  function seedBasePlatforms(){
    const playW = WORLD_MAX_X - WORLD_MIN_X;
    const startW = START_PLATFORM_W;
    const startX = clamp(worldCenterX() - startW * 0.5, WORLD_MIN_X + 24, WORLD_MAX_X - startW - 24);
    const baseW = clamp(playW * 0.62, 320, 560);
    const baseX = worldCenterX() - baseW * 0.5;

    platforms.length = 0;
    platforms.push(
      { x: baseX, y: 640, w: baseW, h: 50, keep: true, crumble: false, standTime: 0, broken: false },
      { x: startX, y: 560, w: startW, h: 16, keep: true, crumble: false, standTime: 0, broken: false }
    );

    nextPlatformY = 560;
    lastPlatformX = startX;
    mainPlatformCount = 0;
    lastMainSide = 0;
    lastMainPlatform = makePlatform(startX, 560, startW, 16, { keep: true });
    earlyPreferredSide = Math.random() < 0.5 ? -1 : 1;
    player.x = startX + (startW - player.w) * 0.5;
    player.y = SPAWN_Y;
  }

  // 발판 생성 범위를 화면 근처로 제한해서
  // 고도 상승 시 "화면은 비었는데 바깥쪽에만 발판 생성"되는 현상을 줄인다.
  function spawnMinX(){ return WORLD_MIN_X - PLATFORM_SPAWN_SIDE_BLEED; }
  function spawnMaxX(width){ return WORLD_MAX_X - width + PLATFORM_SPAWN_SIDE_BLEED; }

  function makePlatform(x, y, w, h, opts = {}){
    return {
      x, y, w, h,
      keep: !!opts.keep,
      crumble: !!opts.crumble,
      standTime: 0,
      decayTime: 0,
      broken: false,
      item: null
    };
  }

  function horizontalGapBetween(from, to){
    if (to.x > from.x + from.w) return to.x - (from.x + from.w);
    if (from.x > to.x + to.w) return from.x - (to.x + to.w);
    return 0;
  }

  function getReachMaxDx(upwardDy, difficulty){
    const t = clamp((upwardDy - 32) / (REACH_MAX_DY - 32), 0, 1);
    return lerp(330, 108, t) * lerp(1.06, 0.90, difficulty);
  }

  function getPreferredMinDx(upwardDy, difficulty){
    const base = clamp(upwardDy * 0.56, 54, 128);
    return base * lerp(1.00, 0.86, difficulty);
  }

  function isReachableFrom(from, to, difficulty){
    const upwardDy = from.y - to.y;
    if (upwardDy < 24 || upwardDy > REACH_MAX_DY) return false;
    const gapX = horizontalGapBetween(from, to);
    return gapX <= getReachMaxDx(upwardDy, difficulty);
  }

  function hasReachableAnchor(candidate, difficulty){
    for (const pl of platforms){
      if (pl.broken) continue;
      if (pl.y <= candidate.y) continue;
      const upwardDy = pl.y - candidate.y;
      if (upwardDy > REACH_MAX_DY + 16) continue;
      if (isReachableFrom(pl, candidate, difficulty)) return true;
    }
    return false;
  }

  function overlapsAnyPlatform(candidate, padding = 6){
    for (const pl of platforms){
      if (pl.broken) continue;
      if (
        candidate.x < pl.x + pl.w + padding &&
        candidate.x + candidate.w > pl.x - padding &&
        candidate.y < pl.y + pl.h + padding &&
        candidate.y + candidate.h > pl.y - padding
      ) return true;
    }
    return false;
  }

  function isBlockingCeiling(from, candidate){
    const upwardDy = from.y - candidate.y;
    if (upwardDy <= 0 || upwardDy > BLOCKING_CEILING_DY) return false;
    const overlapX = Math.max(0, Math.min(from.x + from.w, candidate.x + candidate.w) - Math.max(from.x, candidate.x));
    const overlapNeed = Math.min(from.w, candidate.w) * BLOCKING_CEILING_OVERLAP_RATIO;
    return overlapX >= overlapNeed;
  }

  function countPlatformsInYBand(y, bandDy){
    let count = 0;
    for (const pl of platforms){
      if (pl.broken) continue;
      if (Math.abs(pl.y - y) <= bandDy) count += 1;
    }
    return count;
  }

  function isSmallSingleAnchor(anchor){
    if (!anchor) return false;
    if (anchor.w > SMALL_ANCHOR_W) return false;
    let nearby = 0;
    for (const pl of platforms){
      if (pl.broken) continue;
      if (Math.abs(pl.y - anchor.y) > SMALL_ANCHOR_NEARBY_Y_BAND) continue;
      nearby += 1;
    }
    // If only the anchor level has one-ish footing, treat it as "small single platform".
    return nearby <= 2;
  }

  function isBlockingMainRoute(main, candidate){
    const upwardDy = main.y - candidate.y;
    if (upwardDy < MOBILE_ROUTE_BLOCK_DY_MIN || upwardDy > MOBILE_ROUTE_BLOCK_DY_MAX) return false;
    const overlapX = Math.max(0, Math.min(main.x + main.w, candidate.x + candidate.w) - Math.max(main.x, candidate.x));
    const overlapNeed = Math.min(main.w, candidate.w) * MOBILE_ROUTE_BLOCK_OVERLAP_RATIO;
    return overlapX >= overlapNeed;
  }

  function hasWidePlatformInYBand(y, band = 25, widthRatio = 0.42){
    const playW = WORLD_MAX_X - WORLD_MIN_X;
    for (const pl of platforms){
      if (pl.broken) continue;
      if (Math.abs(pl.y - y) > band) continue;
      if (pl.w >= playW * widthRatio) return true;
    }
    return false;
  }

  function mergeIntervals(intervals){
    if (intervals.length === 0) return [];
    intervals.sort((a, b) => a[0] - b[0]);
    const merged = [intervals[0].slice()];
    for (let i = 1; i < intervals.length; i++){
      const cur = intervals[i];
      const last = merged[merged.length - 1];
      if (cur[0] <= last[1]){
        last[1] = Math.max(last[1], cur[1]);
      } else {
        merged.push(cur.slice());
      }
    }
    return merged;
  }

  function getCeilingTrapAnalysis(anchor, extraPlatforms = [], isMobile = false){
    const rangeTop = anchor.y - (isMobile ? 300 : 260);
    const rangeBottom = anchor.y - (isMobile ? 70 : 80);
    const intervals = [];
    const sources = platforms.concat(extraPlatforms);
    for (const pl of sources){
      if (!pl || pl.broken) continue;
      const plTop = pl.y;
      const plBottom = pl.y + pl.h;
      if (plBottom < rangeTop || plTop > rangeBottom) continue;
      const l = Math.max(WORLD_MIN_X, pl.x);
      const r = Math.min(WORLD_MAX_X, pl.x + pl.w);
      if (r <= l) continue;
      intervals.push([l, r]);
    }
    const blocked = mergeIntervals(intervals);
    const free = [];
    let cursor = WORLD_MIN_X;
    for (const [l, r] of blocked){
      if (l > cursor) free.push([cursor, l]);
      cursor = Math.max(cursor, r);
    }
    if (cursor < WORLD_MAX_X) free.push([cursor, WORLD_MAX_X]);

    const playW = Math.max(1, WORLD_MAX_X - WORLD_MIN_X);
    let blockedLen = 0;
    for (const [l, r] of blocked) blockedLen += (r - l);
    const blockedRatio = blockedLen / playW;
    const anchorCx = anchor.x + anchor.w * 0.5;
    const hasPassageNearAnchor = free.some(([l, r]) => {
      if ((r - l) < CEILING_TRAP_MIN_FREE_W) return false;
      if (anchorCx < l) return (l - anchorCx) <= CEILING_TRAP_NEAR_ANCHOR;
      if (anchorCx > r) return (anchorCx - r) <= CEILING_TRAP_NEAR_ANCHOR;
      return true;
    });

    return {
      blockedRatio,
      freeIntervals: free,
      trap: blockedRatio > CEILING_TRAP_BLOCKED_RATIO && !hasPassageNearAnchor
    };
  }

  function detectCeilingTrap(anchor, extraPlatforms = [], isMobile = false, withLog = true){
    const analysis = getCeilingTrapAnalysis(anchor, extraPlatforms, isMobile);
    if (analysis.trap && withLog){
      const freeText = analysis.freeIntervals
        .map(([l, r]) => `[${Math.round(l)},${Math.round(r)}]`)
        .join(', ');
      console.log(
        `CEILING_TRAP: anchorY=${Math.round(anchor.y)}, blockedRatio=${analysis.blockedRatio.toFixed(2)}, freeIntervals=${freeText}`
      );
    }
    return analysis;
  }

  function buildRescuePlatform(anchor, difficulty, isMobile){
    const playW = WORLD_MAX_X - WORLD_MIN_X;
    const w = clamp(playW * (isMobile ? 0.24 : 0.20), 78, 116);
    const baseDy = isMobile ? rand(98, 138) : rand(88, 126);
    const maxDx = Math.max(46, getReachMaxDx(baseDy, difficulty) * 0.88);
    const minDx = Math.max(36, maxDx * 0.38);
    const anchorCx = anchor.x + anchor.w * 0.5;
    for (let i = 0; i < 24; i++){
      const side = i % 2 === 0 ? -1 : 1;
      const cx = anchorCx + side * rand(minDx, maxDx);
      const x = clamp(cx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      const y = anchor.y - baseDy;
      const rescue = makePlatform(x, y, w, 14);
      if (overlapsAnyPlatform(rescue, 8)) continue;
      if (!isReachableFrom(anchor, rescue, difficulty)) continue;
      return rescue;
    }
    return null;
  }

  function pathCenterXAtY(from, to, y){
    const fromCx = from.x + from.w * 0.5;
    const toCx = to.x + to.w * 0.5;
    const totalDy = Math.max(1, from.y - to.y);
    const t = clamp((from.y - y) / totalDy, 0, 1);
    return lerp(fromCx, toCx, t);
  }

  // Checks whether a platform would block the ascent corridor from "from" to "to".
  function blocksAscentPath(from, to, pl, pad = 10){
    if (pl.broken) return false;
    const lowY = Math.min(from.y, to.y);
    const highY = Math.max(from.y, to.y);
    if (pl.y > highY || pl.y + pl.h < lowY) return false;

    const sampleY = clamp(pl.y + pl.h * 0.5, lowY, highY);
    const pathCx = pathCenterXAtY(from, to, sampleY);
    return pathCx >= (pl.x - pad) && pathCx <= (pl.x + pl.w + pad);
  }

  function routeBlockedByAnyPlatform(from, to, ignoreSet = null){
    for (const pl of platforms){
      if (pl.broken) continue;
      if (ignoreSet && ignoreSet.has(pl)) continue;
      if (blocksAscentPath(from, to, pl, 12)) return true;
    }
    return false;
  }

  function snapshotMainGenState(){
    return {
      lastPlatformX,
      mainPlatformCount,
      lastMainSide,
      lastMainPlatform: lastMainPlatform ? { ...lastMainPlatform } : null,
      routeLen: mainRouteRecent.length,
      mobileDyLen: mainDyRecent.mobile.length,
      desktopDyLen: mainDyRecent.desktop.length
    };
  }

  function restoreMainGenState(snapshot){
    lastPlatformX = snapshot.lastPlatformX;
    mainPlatformCount = snapshot.mainPlatformCount;
    lastMainSide = snapshot.lastMainSide;
    lastMainPlatform = snapshot.lastMainPlatform ? { ...snapshot.lastMainPlatform } : null;
    mainRouteRecent.length = snapshot.routeLen;
    mainDyRecent.mobile.length = snapshot.mobileDyLen;
    mainDyRecent.desktop.length = snapshot.desktopDyLen;
  }

  function spawnMainPlatform(y, opts = {}){
    const anchor = lastMainPlatform;
    const center = worldCenterX();
    const climb = Math.max(0, SPAWN_Y - y);
    const difficulty = clamp(climb / 4200, 0, 1);
    const isMobile = !!opts.isMobile;
    const tuneMinDy = typeof opts.minDy === 'number' ? opts.minDy : MAIN_MIN_DY;
    const tuneMaxDy = typeof opts.maxDy === 'number' ? opts.maxDy : MAIN_MAX_DY;

    let w;
    const bucket = Math.random();
    if (bucket < 0.24) w = rand(lerp(180, 130, difficulty), lerp(250, 190, difficulty));
    else if (bucket < 0.74) w = rand(lerp(130, 92, difficulty), lerp(185, 140, difficulty));
    else w = rand(lerp(95, 68, difficulty), lerp(130, 105, difficulty));
    if (hasWidePlatformInYBand(y, 25, 0.42)){
      const playW = WORLD_MAX_X - WORLD_MIN_X;
      w = Math.min(w, playW * 0.38);
    }
    {
      const playW = WORLD_MAX_X - WORLD_MIN_X;
      const climbRatio = clamp(climb / 3600, 0, 1);
      if (isMobile){
        w = clamp(w * rand(1.10, 1.22), 86, Math.max(132, playW * 0.52));
      }
      const screenCapRatio = isMobile ? MOBILE_MAIN_MAX_W_SCREEN_RATIO : DESKTOP_MAIN_MAX_W_SCREEN_RATIO;
      const hardCap = playW * lerp(screenCapRatio, screenCapRatio - 0.14, climbRatio);
      const randomCap = isMobile
        ? playW * MOBILE_RANDOM_PLATFORM_MAX_W_SCREEN_RATIO
        : playW * RANDOM_PLATFORM_MAX_W_SCREEN_RATIO;
      w = Math.min(w, hardCap, randomCap);
      if (isSmallSingleAnchor(anchor)){
        w = Math.min(w, playW * SMALL_ANCHOR_WIDE_BLOCK_RATIO);
      }
    }

    // 초기 anchor가 없는 경우(이론상 거의 없음) 대비
    if (!anchor){
      const x0 = clamp(center - w * 0.5 + rand(-80, 80), spawnMinX() + 2, spawnMaxX(w) - 2);
      const fallback = makePlatform(x0, y, w, 16);
      lastPlatformX = fallback.x;
      lastMainSide = (fallback.x + w * 0.5) < center ? -1 : 1;
      lastMainPlatform = makePlatform(fallback.x, fallback.y, fallback.w, fallback.h);
      mainPlatformCount += 1;
      return fallback;
    }

    const upwardDy = clamp(anchor.y - y, tuneMinDy, tuneMaxDy);
    const anchorCx = anchor.x + anchor.w * 0.5;
    const maxDxRaw = getReachMaxDx(upwardDy, difficulty);
    const maxDx = Math.max(MAIN_MIN_SHIFT + 8, maxDxRaw - 8);
    const routeMinShiftWanted = isMobile ? MOBILE_MAIN_MIN_SHIFT_HARD : DESKTOP_MAIN_MIN_SHIFT_HARD;
    const routeMinShift = clamp(routeMinShiftWanted, 28, Math.max(30, maxDx - 10));
    const routeMinEdgeGap = isMobile ? MOBILE_MAIN_MIN_EDGE_GAP : DESKTOP_MAIN_MIN_EDGE_GAP;
    const minDxBase = getPreferredMinDx(upwardDy, difficulty);
    const minDx = clamp(Math.max(routeMinShift, minDxBase), routeMinShift, Math.max(routeMinShift + 6, maxDx - 8));
    const preferredSide = lastMainSide === 0 ? (Math.random() < 0.5 ? -1 : 1) : -lastMainSide;
    const sides = [preferredSide, -preferredSide];

    let candidate = null;
    let chosenSide = preferredSide;

    for (let tries = 0; tries < MAIN_ROUTE_RETRY; tries++){
      const side = tries < Math.floor(MAIN_ROUTE_RETRY * 0.7) ? sides[0] : sides[1];
      const dx = rand(minDx, maxDx);
      const targetCx = anchorCx + side * dx + rand(-12, 12);
      const nx = clamp(targetCx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      const c = makePlatform(nx, y, w, 16);
      const shift = Math.abs((c.x + c.w * 0.5) - anchorCx);
      const edgeGap = horizontalGapBetween(anchor, c);
      if (shift < routeMinShift) continue;
      if (edgeGap < routeMinEdgeGap) continue;
      if (isBlockingCeiling(anchor, c)) continue;
      if (overlapsAnyPlatform(c, 8)) continue;
      if (!isReachableFrom(anchor, c, difficulty)) continue;
      if (routeBlockedByAnyPlatform(anchor, c, new Set([anchor]))) continue;
      candidate = c;
      chosenSide = side;
      break;
    }

    // 실패 시 dy/dx를 줄여서라도 반드시 도달 가능한 메인 루트 확보
    if (!candidate){
      for (let relax = 0; relax < 12 && !candidate; relax++){
        const softDy = clamp(upwardDy - relax * 6, tuneMinDy, upwardDy);
        const softMaxDx = Math.max(40, getReachMaxDx(softDy, difficulty) - 6);
        const softMinDx = clamp(minDx * (0.92 - relax * 0.03), 36, softMaxDx - 4);
        const py = anchor.y - softDy;
        for (const side of sides){
          const dx = clamp(rand(softMinDx, softMaxDx), 36, softMaxDx);
          const nx = clamp(anchorCx + side * dx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
          const c = makePlatform(nx, py, w, 16);
          const shift = Math.abs((c.x + c.w * 0.5) - anchorCx);
          const edgeGap = horizontalGapBetween(anchor, c);
          if (shift < Math.max(34, routeMinShift * 0.72)) continue;
          if (edgeGap < Math.max(14, routeMinEdgeGap * 0.66)) continue;
          if (isBlockingCeiling(anchor, c)) continue;
          if (overlapsAnyPlatform(c, 8)) continue;
          if (!isReachableFrom(anchor, c, difficulty)) continue;
          if (routeBlockedByAnyPlatform(anchor, c, new Set([anchor]))) continue;
          candidate = c;
          chosenSide = side;
          break;
        }
      }
    }

    // 마지막 안전장치: 반드시 통과 가능한 위치를 한 번 더 보장
    if (!candidate){
      const side = preferredSide;
      const safeDy = clamp(upwardDy, tuneMinDy, Math.max(tuneMinDy, 118));
      const safeMaxDx = Math.max(44, getReachMaxDx(safeDy, difficulty) - 8);
      const safeDx = clamp(Math.min(Math.max(routeMinShift, minDx), safeMaxDx - 4), 36, safeMaxDx);
      const py = anchor.y - safeDy;
      const nx = clamp(anchorCx + side * safeDx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      candidate = makePlatform(nx, py, w, 16);
      chosenSide = side;
      // 혹시 충돌이면 반대편으로 스왑
      if (overlapsAnyPlatform(candidate, 8) || !isReachableFrom(anchor, candidate, difficulty)){
        const nx2 = clamp(anchorCx - side * safeDx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
        const c2 = makePlatform(nx2, py, w, 16);
        if (!overlapsAnyPlatform(c2, 8) && isReachableFrom(anchor, c2, difficulty)){
          candidate = c2;
          chosenSide = -side;
        }
      }
    }

    if (!candidate || overlapsAnyPlatform(candidate, 8) || !isReachableFrom(anchor, candidate, difficulty)){
      let forced = null;
      for (let dyTry = Math.max(108, tuneMinDy); dyTry >= tuneMinDy && !forced; dyTry -= 6){
        const py = anchor.y - dyTry;
        const maxDxTry = Math.max(30, getReachMaxDx(dyTry, difficulty) - 4);
        const minDxTry = Math.min(Math.max(24, routeMinShift - 24), maxDxTry - 2);
        for (const side of sides){
          for (let dxTry = maxDxTry; dxTry >= minDxTry; dxTry -= 6){
            const nx = clamp(anchorCx + side * dxTry - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
            const c = makePlatform(nx, py, w, 16);
            const edgeGap = horizontalGapBetween(anchor, c);
            if (edgeGap < Math.max(10, routeMinEdgeGap * 0.5)) continue;
            if (overlapsAnyPlatform(c, 8)) continue;
            if (!isReachableFrom(anchor, c, difficulty)) continue;
            forced = c;
            chosenSide = side;
            break;
          }
          if (forced) break;
        }
      }
      if (forced) candidate = forced;
    }

    if (!candidate){
      const py = anchor.y - tuneMinDy;
      const nx = clamp(anchorCx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      candidate = makePlatform(nx, py, w, 16);
      chosenSide = preferredSide;
    }

    const dxLog = Math.round(Math.abs((candidate.x + candidate.w * 0.5) - anchorCx));
    const dyLog = Math.round(anchor.y - candidate.y);
    mainRouteRecent.push({ dx: dxLog, dy: dyLog, side: chosenSide });
    if (mainRouteRecent.length > 10) mainRouteRecent.shift();
    const dyMode = isMobile ? 'mobile' : 'desktop';
    const dyBucket = mainDyRecent[dyMode];
    dyBucket.push(dyLog);
    if (dyBucket.length > 10) dyBucket.shift();
    if (MAIN_ROUTE_DEBUG){
      console.log('[main-route]', mainRouteRecent.map((m) => `dx:${m.dx} dy:${m.dy} side:${m.side > 0 ? 'R' : 'L'}`).join(' | '));
    }
    if (MAIN_DY_DEBUG && isMobile){
      const avgDy = dyBucket.reduce((a, b) => a + b, 0) / Math.max(1, dyBucket.length);
      console.log(
        `[main-dy-mobile] avg(last ${dyBucket.length})=${avgDy.toFixed(1)} ` +
        `values=[${dyBucket.map((v) => String(v)).join(', ')}]`
      );
    }

    lastPlatformX = candidate.x;
    lastMainSide = chosenSide;
    lastMainPlatform = makePlatform(candidate.x, candidate.y, candidate.w, candidate.h);
    mainPlatformCount += 1;
    return candidate;
  }

  function generatePlatformsUpTo(minY){
    while (nextPlatformY > minY){
      const anchorY = lastMainPlatform ? lastMainPlatform.y : nextPlatformY;
      const climbNow = Math.max(0, SPAWN_Y - anchorY);
      const difficulty = clamp(climbNow / 4200, 0, 1);
      const earlyDense = clamp((10 - mainPlatformCount) / 10, 0, 1);
      const isMobile = isMobileMode();
      const baseMinDy = clamp(lerp(MAIN_MIN_DY, MAIN_MIN_DY + 6, difficulty), 86, MAIN_MAX_DY - 16);
      const baseMaxDy = clamp(lerp(MAIN_MAX_DY - 16, MAIN_MAX_DY, difficulty), baseMinDy + 16, MAIN_MAX_DY);
      const safeTop = REACH_MAX_DY - 8;
      const mobileScaledMin = clamp(baseMinDy * 1.18, MOBILE_MAIN_MIN_DY_HARD, safeTop - 20);
      const mobileScaledMax = clamp(baseMaxDy * 1.35, mobileScaledMin + 10, Math.min(safeTop, MOBILE_MAIN_MAX_DY_SAFE));
      const recent3 = mainDyRecent.mobile.slice(-3);
      const smallCount = recent3.filter((v) => v < 150).length;
      const forceLargeDy = isMobile && smallCount >= 2;
      const dyMin = isMobile
        ? (forceLargeDy ? clamp(124, MOBILE_MAIN_MIN_DY_HARD, Math.min(safeTop - 10, MOBILE_MAIN_MAX_DY_SAFE - 10)) : mobileScaledMin)
        : baseMinDy;
      const dyMax = isMobile
        ? (forceLargeDy ? clamp(150, dyMin + 4, Math.min(safeTop, MOBILE_MAIN_MAX_DY_SAFE)) : mobileScaledMax)
        : baseMaxDy;

      let main = null;
      let attempts = 0;
      const prevMainForRoute = lastMainPlatform ? { ...lastMainPlatform } : null;
      const maxMainAttempts = isMobile
        ? Math.max(MOBILE_MAIN_REROLL_MAX, CEILING_TRAP_REROLL_MAX)
        : CEILING_TRAP_REROLL_MAX;
      for (let i = 0; i < maxMainAttempts; i++){
        attempts = i + 1;
        const snapshot = snapshotMainGenState();
        const dy = rand(dyMin, dyMax);
        nextPlatformY = anchorY - dy;

        const candidate = spawnMainPlatform(nextPlatformY, {
          minDy: isMobile ? MOBILE_MAIN_MIN_DY_HARD : baseMinDy,
          maxDy: dyMax,
          isMobile
        });
        const actualDy = anchorY - candidate.y;
        const reachable = !snapshot.lastMainPlatform || isReachableFrom(snapshot.lastMainPlatform, candidate, difficulty);
        if (!reachable){
          restoreMainGenState(snapshot);
          if (isMobile) console.log('[main-mobile] reroll reason: unreachable');
          continue;
        }
        if (isMobile && actualDy < MOBILE_MAIN_MIN_DY_HARD){
          restoreMainGenState(snapshot);
          console.log('[main-mobile] reroll reason: dy too small');
          continue;
        }
        if (prevMainForRoute){
          const trap = detectCeilingTrap(prevMainForRoute, [candidate], isMobile, true);
          if (trap.trap){
            restoreMainGenState(snapshot);
            console.log(`CEILING_TRAP reroll=${attempts}/${maxMainAttempts}`);
            continue;
          }
        }
        main = candidate;
        break;
      }

      if (!main){
        // Hard correction: keep mobile dy at or above minimum reachable threshold.
        const forcedDy = isMobile ? MOBILE_MAIN_MIN_DY_HARD : baseMinDy;
        nextPlatformY = anchorY - forcedDy;
        main = spawnMainPlatform(nextPlatformY, {
          minDy: forcedDy,
          maxDy: forcedDy,
          isMobile
        });
        attempts = Math.max(attempts, isMobile ? MOBILE_MAIN_REROLL_MAX : 1);
      }

      nextPlatformY = main.y;
      if (prevMainForRoute){
        const postTrap = detectCeilingTrap(prevMainForRoute, [main], isMobile, true);
        if (postTrap.trap){
          const rescue = buildRescuePlatform(prevMainForRoute, difficulty, isMobile);
          if (rescue){
            platforms.push(rescue);
          }
        }
      }
      if (isMobile){
        const actualDy = Math.round(anchorY - main.y);
        console.log(
          `[main-mobile] dy:${actualDy} w:${Math.round(main.w)} x:${Math.round(main.x)} ` +
          `y:${Math.round(main.y)} attempts:${attempts}`
        );
      }
      if (!main.keep && mainPlatformCount > 7){
        const crumbleChance = lerp(0.11, 0.23, difficulty);
        if (Math.random() < crumbleChance) main.crumble = true;
      }
      maybeAssignItem(main, difficulty);
      platforms.push(main);

      // 고도 상승 시에도 보조 발판 확률 하한을 높여 밀도 유지
      const subChanceBase = clamp(lerp(0.40, 0.22, difficulty) + earlyDense * 0.20, 0.18, 0.62);
      const subChance = isMobile ? clamp(subChanceBase * 1.18, 0.30, 0.78) : subChanceBase;
      const subRolls = isMobile ? MOBILE_SUB_ROLLS_MAX : 1;
      for (let subIndex = 0; subIndex < subRolls; subIndex++){
        if (Math.random() >= subChance) continue;
        const y = isMobile
          ? (nextPlatformY + rand(6, 26))
          : (nextPlatformY + rand(-18, 18));
        let w = rand(lerp(96, 70, difficulty), lerp(130, 105, difficulty));
        if (hasWidePlatformInYBand(y, 25, 0.42)){
          const playW = WORLD_MAX_X - WORLD_MIN_X;
          w = Math.min(w, playW * 0.38);
        }
        {
          const playW = WORLD_MAX_X - WORLD_MIN_X;
          const climbRatio = clamp(climbNow / 3600, 0, 1);
          if (isMobile){
            const cap = playW * lerp(MOBILE_SUB_MAX_W_SCREEN_RATIO, MOBILE_SUB_MAX_W_SCREEN_RATIO - 0.12, climbRatio);
            w = Math.min(w, cap, playW * MOBILE_RANDOM_PLATFORM_MAX_W_SCREEN_RATIO);
          } else {
            const cap = playW * lerp(DESKTOP_SUB_MAX_W_SCREEN_RATIO, DESKTOP_SUB_MAX_W_SCREEN_RATIO - 0.10, climbRatio);
            w = Math.min(w, cap, playW * RANDOM_PLATFORM_MAX_W_SCREEN_RATIO);
          }
        }
        if (isMobile && countPlatformsInYBand(y, MOBILE_SUB_BAND_DY) >= MOBILE_SUB_BAND_MAX){
          continue;
        }
        let x;
        if (isMobile){
          const mainCy = main.x + main.w * 0.5;
          const upwardDyFromMain = clamp(Math.max(24, main.y - y), 24, REACH_MAX_DY);
          const subMaxDx = Math.max(52, getReachMaxDx(upwardDyFromMain, difficulty) * 0.95);
          const subMinDx = Math.min(84, Math.max(36, subMaxDx * 0.38));
          const side = Math.random() < 0.5 ? -1 : 1;
          const cx = mainCy + side * rand(subMinDx, subMaxDx);
          x = clamp(cx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
        } else {
          x = rand(spawnMinX() + 2, spawnMaxX(w) - 2);
        }
        const mainCenter = main.x + main.w * 0.5;
        const subCenter = x + w * 0.5;
        if (!isMobile && Math.abs(subCenter - mainCenter) < 200){
          x = subCenter < mainCenter
            ? clamp(main.x - rand(240, 340), spawnMinX() + 2, spawnMaxX(w) - 2)
            : clamp(main.x + rand(240, 340), spawnMinX() + 2, spawnMaxX(w) - 2);
        }
        const sub = makePlatform(x, y, w, 14, { crumble: Math.random() < 0.34 && mainPlatformCount > 7 });
        if (isBlockingCeiling(main, sub)) continue;
        if (isMobile && isBlockingMainRoute(main, sub)) continue;
        if (isMobile && prevMainForRoute && blocksAscentPath(prevMainForRoute, main, sub, 12)) continue;
        if (isMobile && prevMainForRoute){
          const trap = detectCeilingTrap(prevMainForRoute, [sub], true, true);
          if (trap.trap) continue;
        }
        let placeable = !overlapsAnyPlatform(sub, 8);
        for (let tries = 0; tries < 10 && !placeable; tries++){
          sub.x = rand(spawnMinX() + 2, spawnMaxX(sub.w) - 2);
          placeable = !overlapsAnyPlatform(sub, 8);
        }
        if (placeable && isMobile){
          placeable = hasReachableAnchor(sub, difficulty) || isReachableFrom(main, sub, difficulty);
        }
        if (placeable){
          maybeAssignItem(sub, difficulty);
          platforms.push(sub);
        }
      }
    }
  }

  function cleanupPlatforms(viewH){
    const cutoffY = cam.y + viewH + 1000;
    for (let i = platforms.length - 1; i >= 0; i--){
      const pl = platforms[i];
      if (pl.keep) continue;
      if (pl.broken){
        platforms.splice(i, 1);
        continue;
      }
      if (pl.y > cutoffY) platforms.splice(i, 1);
    }
  }

  function updateCrumblePlatforms(dt){
    const gp = player.onGround ? player.groundPlatform : null;
    for (const pl of platforms){
      if (!pl.crumble || pl.broken) continue;
      if (pl === gp){
        pl.standTime += dt;
        if (pl.standTime >= CRUMBLE_BREAK_SEC){
          shatterPlatform(pl);
          player.onGround = false;
          player.groundPlatform = null;
        }
      } else {
        pl.standTime = Math.max(0, pl.standTime - dt * 1.7);
      }
    }
  }

  function updateAutoDecayPlatforms(dt){
    for (const pl of platforms){
      if (pl.keep || pl.broken) continue;
      const belowPlayer = pl.y > player.y + player.h + 36;
      if (belowPlayer){
        pl.decayTime = Math.min(AUTO_DECAY_BREAK_SEC + 1.2, pl.decayTime + dt * 1.25);
        if (pl.decayTime >= AUTO_DECAY_BREAK_SEC){
          shatterPlatform(pl);
        }
      } else {
        pl.decayTime = Math.max(0, pl.decayTime - dt * 0.30);
      }
    }
  }

  function isAppleBuffActive(now = performance.now()){
    return now < appleBuffUntil;
  }

  function isBlueWeakActive(now = performance.now()){
    return now < blueWeakUntil;
  }

  function maybeAssignItem(pl, difficulty){
    if (pl.keep || pl.broken) return;
    // 초반 5~6개 메인 발판 구간에서는 아이템 비활성화
    if (mainPlatformCount <= 6) return;
    const chance = lerp(0.38, 0.28, difficulty);
    if (Math.random() > chance) return;
    const type = Math.random() < 0.28 ? 'apple' : 'blueberry';
    pl.item = { type, phase: rand(0, Math.PI * 2) };
  }

  function spawnPickupFx(x, y, color){
    pickupPulseUntil = performance.now() + 260;
    for (let i = 0; i < 10; i++){
      const a = rand(0, Math.PI * 2);
      const s = rand(85, 190);
      debrisParticles.push({
        x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s - 40,
        life: 0.32, maxLife: 0.32, size: rand(2, 4),
        color, grav: 380
      });
    }
  }

  function showPickupText(text){
    pickupText = text;
    pickupTextUntil = performance.now() + 1300;
  }

  function shatterPlatform(pl){
    if (pl.broken || pl.keep) return;
    pl.broken = true;
    breakCrackFx.push({ x: pl.x, y: pl.y, w: pl.w, h: pl.h, life: 0.16, maxLife: 0.16 });

    const pieces = Math.max(8, Math.floor(pl.w / 16));
    for (let i = 0; i < pieces; i++){
      const px = pl.x + rand(0, pl.w);
      const py = pl.y + rand(1, pl.h - 1);
      const ang = rand(-Math.PI, 0);
      const spd = rand(120, 340);
      debrisParticles.push({
        x: px, y: py,
        vx: Math.cos(ang) * spd + rand(-60, 60),
        vy: Math.sin(ang) * spd - rand(30, 120),
        life: rand(0.42, 0.7), maxLife: 0.7,
        size: rand(2, 6),
        color: pl.crumble ? '#8f6b6e' : '#5169cf',
        grav: 720
      });
    }
  }

  function updateEffects(dt){
    for (let i = debrisParticles.length - 1; i >= 0; i--){
      const p = debrisParticles[i];
      p.vy += (p.grav || 600) * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) debrisParticles.splice(i, 1);
    }
    for (let i = breakCrackFx.length - 1; i >= 0; i--){
      breakCrackFx[i].life -= dt;
      if (breakCrackFx[i].life <= 0) breakCrackFx.splice(i, 1);
    }
  }

  function spawnSeaBubble(){
    const W = viewportW || Math.round(window.innerWidth);
    seaBubbles.push({
      x: rand(10, Math.max(12, W - 10)),
      y: (viewportH || Math.round(window.innerHeight)) + rand(6, 38),
      r: rand(1.8, 6.6),
      vy: rand(26, 74),
      swayAmp: rand(4, 18),
      swaySpeed: rand(0.8, 2.2),
      t: rand(0, Math.PI * 2),
      alpha: rand(0.18, 0.52)
    });
  }

  function updateSeaBubbles(dt){
    const H = viewportH || Math.round(window.innerHeight);
    seaBubbleSpawnAcc += dt * SEA_BUBBLE_SPAWN_PER_SEC;
    while (seaBubbleSpawnAcc >= 1 && seaBubbles.length < SEA_BUBBLE_MAX){
      seaBubbleSpawnAcc -= 1;
      spawnSeaBubble();
    }

    for (let i = seaBubbles.length - 1; i >= 0; i--){
      const b = seaBubbles[i];
      b.t += dt * b.swaySpeed;
      b.y -= b.vy * dt;
      if (b.y + b.r < -40){
        seaBubbles.splice(i, 1);
      }
    }

    // Keep a few bubbles alive at all times.
    if (seaBubbles.length < 6){
      for (let i = seaBubbles.length; i < 6; i++) spawnSeaBubble();
    }
    // If viewport height changed, softly clamp far-off bubbles.
    for (const b of seaBubbles){
      if (b.y > H + 100) b.y = H + rand(8, 60);
    }
  }

  function drawSeaBubbles(){
    for (const b of seaBubbles){
      const sx = b.x + Math.sin(b.t) * b.swayAmp;
      const a = b.alpha * clamp(1 - b.y / Math.max(1, (viewportH || Math.round(window.innerHeight)) + 40), 0.2, 1);
      ctx.strokeStyle = `rgba(168, 215, 255, ${a})`;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.arc(sx, b.y, b.r, 0, Math.PI * 2);
      ctx.stroke();

      ctx.fillStyle = `rgba(196, 232, 255, ${a * 0.26})`;
      ctx.beginPath();
      ctx.arc(sx + b.r * 0.15, b.y - b.r * 0.18, Math.max(0.8, b.r * 0.34), 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function makeDeepSeaFish(y){
    const aspect = eelSpriteImg
      ? (eelSpriteImg.naturalWidth || eelSpriteImg.width || 1) / Math.max(1, (eelSpriteImg.naturalHeight || eelSpriteImg.height || 1))
      : FISH_FALLBACK_ASPECT;
    const fishH = FISH_TARGET_H;
    const fishW = Math.max(56, Math.round(fishH * aspect));
    const laneMinX = WORLD_MIN_X + 12;
    const laneMaxX = WORLD_MAX_X - fishW - 12;
    return {
      x: rand(laneMinX, Math.max(laneMinX, laneMaxX)),
      y,
      w: fishW,
      h: fishH,
      dir: Math.random() < 0.5 ? -1 : 1,
      speed: rand(58, 128),
      phase: rand(0, Math.PI * 2),
      bobAmp: rand(3, 8),
      bobSpeed: rand(1.4, 2.6),
      hue: Math.random() < 0.5 ? 'cyan' : 'indigo'
    };
  }

  function fishWorldY(f, now){
    return f.y + Math.sin(now * 0.001 * f.bobSpeed + f.phase) * f.bobAmp;
  }

  function generateFishUpTo(minY){
    while (nextFishSpawnY > minY){
      deepSeaFish.push(makeDeepSeaFish(nextFishSpawnY));
      nextFishSpawnY -= rand(FISH_SPAWN_GAP_MIN, FISH_SPAWN_GAP_MAX);
    }
  }

  function cleanupFish(viewH){
    const cutoffY = cam.y + viewH + 280;
    for (let i = deepSeaFish.length - 1; i >= 0; i--){
      if (deepSeaFish[i].y > cutoffY) deepSeaFish.splice(i, 1);
    }
  }

  function updateDeepSeaFish(dt, now){
    const laneMinX = WORLD_MIN_X + 12;

    for (const f of deepSeaFish){
      const laneMaxX = WORLD_MAX_X - f.w - 12;
      f.x += f.dir * f.speed * dt;
      if (f.x <= laneMinX){
        f.x = laneMinX;
        f.dir = 1;
      } else if (f.x >= laneMaxX){
        f.x = laneMaxX;
        f.dir = -1;
      }
    }

    if (now < fishHitCooldownUntil) return;

    for (const f of deepSeaFish){
      const fy = fishWorldY(f, now);
      if (!aabb(player.x, player.y, player.w, player.h, f.x, fy, f.w, f.h)) continue;

      const fishCx = f.x + f.w * 0.5;
      const playerCx = player.x + player.w * 0.5;
      const pushDir = playerCx <= fishCx ? -1 : 1;
      player.vx = pushDir * Math.max(180, Math.abs(player.vx) + 80);
      player.vy = Math.max(player.vy, 980);
      player.onGround = false;
      player.groundPlatform = null;
      residualMomentum.strength = 0;
      fishHitCooldownUntil = now + FISH_HIT_COOLDOWN_MS;
      break;
    }
  }

  function drawDeepSeaFish(now){
    for (const f of deepSeaFish){
      const fy = fishWorldY(f, now);
      const sy = fy - cam.y;
      if (eelSpriteImg){
        const facing = f.dir >= 0 ? -1 : 1;
        const cx = Math.round(f.x + f.w * 0.5);
        const cy = Math.round(sy + f.h * 0.5);
        const wriggle = Math.sin(now * 0.009 + f.phase);
        const breathe = Math.sin(now * 0.0055 + f.phase * 0.9);
        const rot = wriggle * 0.055;
        const scaleX = 1 + wriggle * 0.02;
        const scaleY = 1 + breathe * 0.04;
        const dw = Math.max(1, Math.round(f.w));
        const dh = Math.max(1, Math.round(f.h));

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);
        ctx.scale(facing, 1);
        ctx.scale(scaleX, scaleY);
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(eelSpriteImg, -dw * 0.5, -dh * 0.5, dw, dh);
        ctx.restore();
        continue;
      }

      const body = f.hue === 'cyan' ? '#1f5568' : '#313a74';
      const bodyDark = f.hue === 'cyan' ? '#123645' : '#1c224f';
      const finEdge = f.hue === 'cyan' ? '#3f7e96' : '#5561a3';
      const teeth = '#ecf4ff';
      const eye = '#edf5ff';
      const facing = f.dir >= 0 ? 1 : -1;
      const cx = f.x + f.w * 0.5;
      const cy = sy + f.h * 0.5;

      // Body
      ctx.fillStyle = body;
      ctx.beginPath();
      ctx.ellipse(cx, cy, f.w * 0.38, f.h * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();

      // Tail
      ctx.fillStyle = bodyDark;
      ctx.beginPath();
      ctx.moveTo(cx - facing * f.w * 0.40, cy);
      ctx.lineTo(cx - facing * f.w * 0.58, cy - f.h * 0.24);
      ctx.lineTo(cx - facing * f.w * 0.58, cy + f.h * 0.24);
      ctx.closePath();
      ctx.fill();

      // Dorsal fin
      ctx.fillStyle = finEdge;
      ctx.beginPath();
      ctx.moveTo(cx - f.w * 0.04, cy - f.h * 0.30);
      ctx.lineTo(cx + f.w * 0.12, cy - f.h * 0.52);
      ctx.lineTo(cx + f.w * 0.20, cy - f.h * 0.24);
      ctx.closePath();
      ctx.fill();

      // Mouth slit
      const mouthX = cx + facing * f.w * 0.28;
      const mouthY = cy + f.h * 0.08;
      ctx.strokeStyle = '#0d1222';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mouthX - facing * 8, mouthY - 1);
      ctx.lineTo(mouthX + facing * 4, mouthY + 1);
      ctx.stroke();

      // Teeth (small spikes)
      ctx.fillStyle = teeth;
      const toothDir = facing > 0 ? 1 : -1;
      for (let i = 0; i < 4; i++){
        const tx = mouthX - toothDir * (6 - i * 3.4);
        const ty = mouthY - 1;
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(tx + toothDir * 2.1, ty + 0.6);
        ctx.lineTo(tx + toothDir * 0.9, ty + 3.6);
        ctx.closePath();
        ctx.fill();
      }

      // Angry half-circle eye
      ctx.fillStyle = eye;
      ctx.beginPath();
      ctx.arc(cx + facing * f.w * 0.20, cy - f.h * 0.08, f.h * 0.12, Math.PI, 0);
      ctx.lineTo(cx + facing * f.w * 0.20 + f.h * 0.12, cy - f.h * 0.08);
      ctx.closePath();
      ctx.fill();

      // Pupil + angry brow
      ctx.fillStyle = '#11192a';
      ctx.beginPath();
      ctx.arc(cx + facing * f.w * 0.21, cy - f.h * 0.10, f.h * 0.045, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#0b1020';
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.moveTo(cx + facing * f.w * 0.12, cy - f.h * 0.18);
      ctx.lineTo(cx + facing * f.w * 0.30, cy - f.h * 0.26);
      ctx.stroke();
    }
  }

  function updateItemCollection(now){
    const pcx = player.x + player.w * 0.5;
    const pcy = player.y + player.h * 0.5;
    for (const pl of platforms){
      if (pl.broken || !pl.item) continue;
      const itemX = pl.x + pl.w * 0.5;
      const itemY = pl.y - 11 + Math.sin(now * ITEM_BOB_SPEED + pl.item.phase) * ITEM_BOB_AMP;
      const d = Math.hypot(itemX - pcx, itemY - pcy);
      if (d > 24) continue;

      if (pl.item.type === 'apple'){
        appleBuffUntil = Math.max(appleBuffUntil, now + APPLE_BUFF_MS);
        spawnPickupFx(itemX, itemY, '#ff6b6b');
        showPickupText('운이의 힘이 굉장히 세졌습니다');
      } else {
        blueWeakUntil = Math.max(blueWeakUntil, now + BLUE_WEAK_MS);
        spawnPickupFx(itemX, itemY, '#ffd84d');
        showPickupText('운이가 자신감 있게 점프합니다');
      }
      pl.item = null;
    }
  }

  function getPlayerTint(now){
    const appleRem = appleBuffUntil - now;
    const yellowRem = blueWeakUntil - now;
    const rem = Math.max(appleRem, yellowRem);
    if (rem <= 0) return null;

    const color = appleRem >= yellowRem ? '#ff5a66' : '#ffd84d';
    let alpha = 0.36;
    if (rem <= 3000){
      const blinkOn = Math.sin(now * 0.032) > 0;
      alpha = blinkOn ? 0.34 : 0.06;
    }
    return { color, alpha };
  }

  function drawItemVisual(item, sx, sy){
    if (item.type === 'apple'){
      ctx.fillStyle = '#e84d5b';
      ctx.fillRect(sx - 5, sy - 5, 10, 10);
      ctx.fillStyle = '#ff7b86';
      ctx.fillRect(sx - 2, sy - 4, 3, 3);
      ctx.fillStyle = '#603820';
      ctx.fillRect(sx - 1, sy - 8, 2, 3);
      ctx.fillStyle = '#58b46a';
      ctx.fillRect(sx + 1, sy - 9, 3, 2);
    } else {
      ctx.fillStyle = '#f4cd38';
      ctx.fillRect(sx - 4, sy - 4, 8, 8);
      ctx.fillRect(sx - 6, sy - 2, 3, 3);
      ctx.fillRect(sx + 3, sy - 2, 3, 3);
      ctx.fillStyle = '#ffe88f';
      ctx.fillRect(sx - 1, sy - 2, 2, 2);
    }
  }

  function drawDebrisAndCracks(){
    for (const fx of breakCrackFx){
      const a = clamp(fx.life / fx.maxLife, 0, 1);
      const sy = fx.y - cam.y;
      ctx.strokeStyle = `rgba(220, 170, 170, ${0.65 * a})`;
      ctx.lineWidth = 1;
      const c1 = fx.x + fx.w * 0.2;
      const c2 = fx.x + fx.w * 0.46;
      const c3 = fx.x + fx.w * 0.72;
      ctx.beginPath();
      ctx.moveTo(c1, sy + 2); ctx.lineTo(c1 + 8, sy + fx.h - 2);
      ctx.moveTo(c2, sy + 1); ctx.lineTo(c2 - 6, sy + fx.h * 0.6); ctx.lineTo(c2 + 6, sy + fx.h - 2);
      ctx.moveTo(c3, sy + 2); ctx.lineTo(c3 - 7, sy + fx.h - 2);
      ctx.stroke();
    }

    for (const p of debrisParticles){
      const a = clamp(p.life / (p.maxLife || 1), 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color || '#9fb2ff';
      ctx.fillRect(p.x, p.y - cam.y, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  // ===== Score & Time =====
  let startY = player.y;
  let bestY = player.y;
  let t0 = performance.now();
  let hudOriginX = player.x;
  let hudOriginY = player.y;

  function score(){
    return Math.max(0, Math.floor((startY - bestY) / 10));
  }
  function elapsedSec(){
    if (frozenElapsedSec !== null) return frozenElapsedSec;
    return Math.floor((performance.now() - t0) / 1000);
  }

  // ===== Input: Charge Jump =====
  const input = {
    aiming: false,
    pid: null,
    startX: 0, startY: 0,
    curX: 0, curY: 0,
    pullX: 0, pullY: 0,
  };

  function pointerPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  const PLAYER_SPRITES = {
    cat: [
      '.1.......1...',
      '11.1...1.11..',
      '1ww1111ww11..',
      '1wwwwwwwww11.',
      '1w2www2www11.',
      '1wwwwwwwww11.',
      '.1w333333w11.',
      '.1wwwwwwww11.',
      '.1ww1ww1ww11.',
      '.1wwwwwwww11.',
      '.1ww4444ww11.',
      '.1www44www11.',
      '..11111111...',
      '..1......1...',
      '.11......11..',
      '.1........1..',
      '11........11.',
    ],
    dog: [
      '.111.....111.',
      '.1bb1...1bb1.',
      '11bbb111bbb11',
      '1bbbbbbbbbbb1',
      '1bb2bbbb2bbb1',
      '1bbbbbbbbbbb1',
      '1bbb33333bbb1',
      '.1bbbbbbbbb1.',
      '.1bbb1b1bbb1.',
      '.1bbbbbbbbb1.',
      '.1bbb444bbb1.',
      '..1bb444bb1..',
      '..111111111..',
      '..1.......1..',
      '.11.......11.',
      '.1.........1.',
      '11.........11',
    ],
  };
  const PLAYER_PALETTES = {
    cat: { '1':'#1f2f66', 'w':'#eaf1ff', '2':'#6b8cff', '3':'#ff9eb4', '4':'#d8e4ff', 'b':'#f5d7af' },
    dog: { '1':'#1f2f66', 'w':'#eaf1ff', '2':'#6b8cff', '3':'#3f3020', '4':'#f3eadb', 'b':'#deb37f' },
  };
  let fixedSpriteImg = null;
  let fixedSpriteTrim = null;
  let fixedSpriteLegColor = '#2a2f40';

  function computeOpaqueBounds(img){
    const iw = img.naturalWidth || img.width || 1;
    const ih = img.naturalHeight || img.height || 1;
    const off = document.createElement('canvas');
    off.width = iw;
    off.height = ih;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.clearRect(0, 0, iw, ih);
    octx.drawImage(img, 0, 0, iw, ih);

    const { data } = octx.getImageData(0, 0, iw, ih);
    let minX = iw, minY = ih, maxX = -1, maxY = -1;
    for (let y = 0; y < ih; y++){
      for (let x = 0; x < iw; x++){
        const a = data[(y * iw + x) * 4 + 3];
        if (a < 10) continue;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
    }

    if (maxX < minX || maxY < minY){
      return { sx: 0, sy: 0, sw: iw, sh: ih };
    }
    return { sx: minX, sy: minY, sw: (maxX - minX + 1), sh: (maxY - minY + 1) };
  }

  function computeRearLegColor(img, trim){
    const iw = img.naturalWidth || img.width || 1;
    const ih = img.naturalHeight || img.height || 1;
    const off = document.createElement('canvas');
    off.width = iw;
    off.height = ih;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.clearRect(0, 0, iw, ih);
    octx.drawImage(img, 0, 0, iw, ih);
    const { data } = octx.getImageData(0, 0, iw, ih);

    const rx0 = Math.floor(trim.sx + trim.sw * 0.00);
    const rx1 = Math.ceil(trim.sx + trim.sw * 0.45);
    const ry0 = Math.floor(trim.sy + trim.sh * 0.55);
    const ry1 = Math.ceil(trim.sy + trim.sh * 1.00);

    let r = 0, g = 0, b = 0, n = 0;
    for (let y = ry0; y < ry1; y++){
      for (let x = rx0; x < rx1; x++){
        const a = data[(y * iw + x) * 4 + 3];
        if (a < 20) continue;
        const j = (y * iw + x) * 4;
        r += data[j];
        g += data[j + 1];
        b += data[j + 2];
        n += 1;
      }
    }
    if (n === 0) return '#2a2f40';
    const rr = Math.round(r / n).toString(16).padStart(2, '0');
    const gg = Math.round(g / n).toString(16).padStart(2, '0');
    const bb = Math.round(b / n).toString(16).padStart(2, '0');
    return `#${rr}${gg}${bb}`;
  }

  function getJumpLegStretch(now){
    if (isGameOver || player.onGround) return 0;
    const launchStretch = clamp((jumpStretchUntil - now) / JUMP_LEG_STRETCH_MS, 0, 1);
    const airStretch = clamp((-player.vy - 40) / 560, 0, 1) * 0.85;
    return Math.max(launchStretch, airStretch);
  }

  function loadFixedSprite(){
    const img = new Image();
    img.onload = () => {
      fixedSpriteImg = img;
      fixedSpriteTrim = computeOpaqueBounds(img);
      fixedSpriteLegColor = computeRearLegColor(img, fixedSpriteTrim);
    };
    img.onerror = () => {
      console.warn(`[jumpking_proto] failed to load fixed sprite: ${FIXED_SPRITE_SRC}`);
    };
    img.src = FIXED_SPRITE_SRC;
  }

  function loadEelSprite(){
    const img = new Image();
    img.onload = () => {
      eelSpriteImg = img;
    };
    img.onerror = () => {
      console.warn(`[jumpking_proto] failed to load eel sprite: ${EEL_SPRITE_SRC}`);
    };
    img.src = EEL_SPRITE_SRC;
  }

  function drawPixelSprite(kind, x, y, facing = 1, tint = null){
    if (fixedSpriteImg){
      const trim = fixedSpriteTrim || {
        sx: 0,
        sy: 0,
        sw: (fixedSpriteImg.naturalWidth || fixedSpriteImg.width || 1),
        sh: (fixedSpriteImg.naturalHeight || fixedSpriteImg.height || 1)
      };
      const scale = Math.min(player.w / trim.sw, player.h / trim.sh);
      const dw = trim.sw * scale;
      const dh = trim.sh * scale;
      const ox = x + (player.w - dw) * 0.5;
      const oy = y + (player.h - dh);
      const stretch = getJumpLegStretch(performance.now());
      const tw = Math.max(1, Math.round(dw));
      const th = Math.max(1, Math.round(dh));

      if (spriteFxCanvas.width !== tw || spriteFxCanvas.height !== th){
        spriteFxCanvas.width = tw;
        spriteFxCanvas.height = th;
      }
      spriteFxCtx.clearRect(0, 0, tw, th);
      spriteFxCtx.imageSmoothingEnabled = false;
      if (facing < 0){
        spriteFxCtx.save();
        spriteFxCtx.translate(tw, 0);
        spriteFxCtx.scale(-1, 1);
        spriteFxCtx.drawImage(fixedSpriteImg, trim.sx, trim.sy, trim.sw, trim.sh, 0, 0, tw, th);
        spriteFxCtx.restore();
      } else {
        spriteFxCtx.drawImage(fixedSpriteImg, trim.sx, trim.sy, trim.sw, trim.sh, 0, 0, tw, th);
      }
      if (tint){
        spriteFxCtx.globalCompositeOperation = 'source-atop';
        spriteFxCtx.globalAlpha = tint.alpha;
        spriteFxCtx.fillStyle = tint.color;
        spriteFxCtx.fillRect(0, 0, tw, th);
        spriteFxCtx.globalCompositeOperation = 'source-over';
        spriteFxCtx.globalAlpha = 1;
      }

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(spriteFxCanvas, ox, oy, dw, dh);

      if (stretch > 0.01){
        const legW = Math.max(2, Math.floor(dw * 0.09));
        const legGap = Math.max(3, Math.floor(dw * 0.12));
        const legX0 = Math.floor(dw * 0.13);
        const legY = Math.floor(dh * 0.74);
        const legH = Math.floor(6 + stretch * JUMP_LEG_STRETCH_MAX);
        const legXFront = facing < 0
          ? Math.floor(dw - legX0 - legW)
          : legX0;
        const legXRear = facing < 0
          ? Math.floor(dw - (legX0 + legGap) - legW)
          : (legX0 + legGap);

        ctx.fillStyle = fixedSpriteLegColor;
        ctx.fillRect(ox + legXFront, oy + legY, legW, legH);
        ctx.fillRect(ox + legXRear, oy + legY + 1, legW, Math.max(3, legH - 1));
      }
      ctx.restore();
      return;
    }

    const sprite = PLAYER_SPRITES[kind] || PLAYER_SPRITES.cat;
    const palette = PLAYER_PALETTES[kind] || PLAYER_PALETTES.cat;
    const scale = Math.min(player.w / sprite[0].length, player.h / sprite.length);
    const ox = x + (player.w - sprite[0].length * scale) * 0.5;
    const oy = y + (player.h - sprite.length * scale) * 0.5;

    for (let r = 0; r < sprite.length; r++){
      const row = sprite[r];
      for (let c = 0; c < row.length; c++){
        const ch = row[c];
        if (ch === '.') continue;
        const color = palette[ch];
        if (!color) continue;
        const cc = facing < 0 ? (row.length - 1 - c) : c;
        ctx.fillStyle = color;
        ctx.fillRect(ox + cc * scale, oy + r * scale, scale, scale);
      }
    }
  }

  function playerScreenCenter(){
    return {
      x: player.x + player.w/2,
      y: (player.y - cam.y) + player.h/2
    };
  }

  function hitPlayerScreen(px, py){
    const mobilePad = isMobileMode() ? 16 : 0;
    const hitPad = INPUT_HIT_PAD + mobilePad;
    const s = { x: player.x, y: (player.y - cam.y) };
    return px >= s.x - hitPad && px <= s.x + player.w + hitPad
      && py >= s.y - hitPad && py <= s.y + player.h + hitPad;
  }

  function beginAim(e){
    if (isGameOver) return;
    if (!isFullyStopped()) return;

    const p = pointerPos(e);
    if (!hitPlayerScreen(p.x, p.y)) return;

    const c = playerScreenCenter();

    input.aiming = true;
    input.pid = e.pointerId;
    input.startX = c.x;
    input.startY = c.y;
    input.curX = p.x;
    input.curY = p.y;
    input.pullX = 0;
    input.pullY = 0;

    canvas.setPointerCapture?.(e.pointerId);
  }

  function moveAim(e){
    if (isGameOver) return;
    if (!input.aiming || e.pointerId !== input.pid) return;

    const p = pointerPos(e);
    input.curX = p.x;
    input.curY = p.y;

    let dx = input.curX - input.startX;
    let dy = input.curY - input.startY;
    dy = Math.max(0, dy);

    dx = clamp(dx, -MAX_PULL, MAX_PULL);
    dy = clamp(dy, 0, MAX_PULL);

    const dist = Math.hypot(dx, dy);
    if (dist > MAX_PULL){
      const s = MAX_PULL / dist;
      dx *= s;
      dy *= s;
    }

    input.pullX = dx;
    input.pullY = dy;
  }

  function endAim(e){
    if (isGameOver) return;
    if (!input.aiming || e.pointerId !== input.pid) return;

    const pullLen = Math.hypot(input.pullX, input.pullY);

    input.aiming = false;
    input.pid = null;

    if (pullLen < MIN_PULL_TO_JUMP) return;

    const power = clamp(pullLen / MAX_PULL, 0, 1);
    const now = performance.now();
    const jumpScale = isBlueWeakActive(now) ? BLUE_JUMP_SCALE : 1;
    const vy = -power * MAX_JUMP_VY * jumpScale;
    const vx = (input.pullX / MAX_PULL) * MAX_JUMP_VX * power * jumpScale;

    player.vx = vx;
    player.vy = vy;
    player.onGround = false;
    jumpStretchUntil = now + JUMP_LEG_STRETCH_MS;
    if (Math.abs(vx) > 8) playerFacing = Math.sign(vx);

    const n = Math.hypot(vx, vy) || 1;
    residualMomentum.dirX = vx / n;
    residualMomentum.dirY = vy / n;
    residualMomentum.strength = power;
  }

  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); beginAim(e); }, { passive:false });
  canvas.addEventListener('pointermove', (e)=>{ if(input.aiming) e.preventDefault(); moveAim(e); }, { passive:false });
  canvas.addEventListener('pointerup',   (e)=>{ e.preventDefault(); endAim(e); }, { passive:false });
  canvas.addEventListener('pointercancel',(e)=>{ endAim(e); }, { passive:true });

  // ===== Collision =====
  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function applyWrapX(){
    if (player.x + player.w < WORLD_MIN_X){
      player.x = WORLD_MAX_X;
    } else if (player.x > WORLD_MAX_X){
      player.x = WORLD_MIN_X - player.w;
    }
  }

  function applyCollisionMomentum(blockAxis, impactSpeed){
    if (residualMomentum.strength < MOMENTUM_MIN_POWER) return false;
    if (impactSpeed < MOMENTUM_IMPACT_SPEED) return false;

    const carry = clamp((residualMomentum.strength - MOMENTUM_MIN_POWER) / (1 - MOMENTUM_MIN_POWER), 0, 1);

    if (blockAxis === 'x'){
      const tangentDir = residualMomentum.dirY !== 0
        ? Math.sign(residualMomentum.dirY)
        : (player.vy === 0 ? -1 : Math.sign(player.vy));
      const tangentGain = Math.max(80, impactSpeed * (0.16 + 0.26 * carry));
      player.vy += tangentDir * tangentGain;
      player.vx = -Math.sign(player.vx || residualMomentum.dirX || 1) * Math.min(90, impactSpeed * 0.14);
    } else {
      const tangentDir = residualMomentum.dirX !== 0
        ? Math.sign(residualMomentum.dirX)
        : (player.vx === 0 ? 0 : Math.sign(player.vx));
      const tangentGain = Math.max(70, impactSpeed * (0.20 + 0.34 * carry));
      player.vx += tangentDir * tangentGain;
      player.vy = Math.max(player.vy, 40);
    }

    residualMomentum.strength *= 0.72;
    return true;
  }

  function resolve(dt){
    player.onGround = false;
    player.groundPlatform = null;
    const prevY = player.y;

    // X move
    player.x += player.vx * dt;
    if (Math.abs(player.vx) > 18) playerFacing = Math.sign(player.vx);
    for (const pl of platforms){
      if (pl.broken) continue;
      if (!aabb(player.x, player.y, player.w, player.h, pl.x, pl.y, pl.w, pl.h)) continue;

      const impactX = Math.abs(player.vx);
      if (isAppleBuffActive() && !pl.keep && impactX > APPLE_BREAK_IMPACT){
        shatterPlatform(pl);
        continue;
      }

      // 코너 스침(세로 겹침이 매우 얕은 경우)은 옆벽 충돌로 처리하지 않는다.
      // 이걸 허용하면 "보이지 않는 벽"처럼 옆으로 밀려 착지를 놓치는 현상이 줄어든다.
      const pTop = player.y;
      const pBottom = player.y + player.h;
      const overlapY = Math.min(pBottom, pl.y + pl.h) - Math.max(pTop, pl.y);
      if (overlapY <= 6) continue;

      // 발판 윗면 착지 직전 상황은 X보다 Y 처리(착지)를 우선한다.
      const nextBottom = (player.y + player.vy * dt) + player.h;
      if (player.vy >= 0 && pBottom <= pl.y + 8 && nextBottom >= pl.y - 2) continue;

      if (player.vx > 0) player.x = pl.x - player.w;
      else if (player.vx < 0) player.x = pl.x + pl.w;
      if (!applyCollisionMomentum('x', impactX)) player.vx = 0;
    }
    applyWrapX();

    // Y move
    player.y += player.vy * dt;
    for (const pl of platforms){
      if (pl.broken) continue;
      const overlapsX = player.x < pl.x + pl.w && player.x + player.w > pl.x;
      if (!overlapsX) continue;

      const prevTop = prevY;
      const prevBottom = prevY + player.h;
      const curTop = player.y;
      const curBottom = player.y + player.h;

      if (player.vy > 0){
        if (prevBottom <= pl.y && curBottom >= pl.y){
          player.y = pl.y - player.h;
          player.vy = 0;
          player.onGround = true;
          player.groundPlatform = pl;
          break;
        }
      } else if (player.vy < 0){
        const plBottom = pl.y + pl.h;
        if (prevTop >= plBottom && curTop <= plBottom){
          const impactY = Math.abs(player.vy);
          if (isAppleBuffActive() && !pl.keep && impactY > APPLE_BREAK_IMPACT){
            shatterPlatform(pl);
            continue;
          }
          player.y = plBottom;
          if (!applyCollisionMomentum('y', impactY)) player.vy = 0;
          break;
        }
      }

      if (!aabb(player.x, player.y, player.w, player.h, pl.x, pl.y, pl.w, pl.h)) continue;
      if (player.vy >= 0){
        player.y = pl.y - player.h;
        player.vy = 0;
        player.onGround = true;
        player.groundPlatform = pl;
        break;
      } else {
        const impactY = Math.abs(player.vy);
        if (isAppleBuffActive() && !pl.keep && impactY > APPLE_BREAK_IMPACT){
          shatterPlatform(pl);
          continue;
        }
        player.y = pl.y + pl.h;
        if (!applyCollisionMomentum('y', impactY)) player.vy = 0;
        break;
      }
    }

    if (player.onGround){
      player.vx *= GROUND_DAMP;
      if (Math.abs(player.vx) < STATIC_VX_EPS) player.vx = 0;
      if (Math.abs(player.vy) < STATIC_VY_EPS) player.vy = 0;
      residualMomentum.strength *= 0.88;
    } else {
      residualMomentum.strength *= 0.996;
    }
    if (residualMomentum.strength < 0.02){
      residualMomentum.strength = 0;
    }
  }

  function setGameOver(v){
    isGameOver = v;
    gameOverOverlay.classList.toggle('show', v);
    if (v){
      if (frozenElapsedSec === null) frozenElapsedSec = Math.floor((performance.now() - t0) / 1000);
      input.aiming = false;
      input.pid = null;
      submitRankOnGameOver();
    } else {
      frozenElapsedSec = null;
    }
  }

  function checkGameOver(){
    const H = viewportH || Math.round(window.innerHeight);
    const outBelow = (player.y - cam.y) > (H + BOTTOM_OUT_MARGIN);
    if (outBelow) setGameOver(true);
  }

  async function submitRankOnGameOver(){
    if (rankSubmittedThisRound) return;
    rankSubmittedThisRound = true;

    const name = prompt("이름 입력 (12자 이내)");
    if (!name) return;

    const submit = window.leaderboardSubmit;
    if (typeof submit !== 'function'){
      console.warn('leaderboardSubmit is not ready');
      alert("랭킹 모듈이 아직 준비되지 않았어요. URL/KEY 또는 네트워크를 확인해줘.");
      return;
    }

    const res = await submit(name, score());
    if (!res?.ok){
      const msg = typeof res?.error === 'string'
        ? res.error
        : (res?.error?.message || JSON.stringify(res?.error || {}));
      alert(`저장 실패: ${msg}`);
    }
  }

  function resetGame(){
    updateWorldBounds();
    seedBasePlatforms();
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    cam.y = 0;

    generatePlatformsUpTo(player.y - (viewportH || Math.round(window.innerHeight)) * 2.2);

    startY = player.y;
    bestY = player.y;
    t0 = performance.now();
    hudOriginX = player.x;
    hudOriginY = player.y;
    frozenElapsedSec = null;

    input.aiming = false;
    input.pid = null;
    residualMomentum.dirX = 0;
    residualMomentum.dirY = -1;
    residualMomentum.strength = 0;
    appleBuffUntil = 0;
    blueWeakUntil = 0;
    pickupPulseUntil = 0;
    pickupText = '';
    pickupTextUntil = 0;
    storyShown = false;
    clearStoryToastTimers();
    storyToastEl.classList.remove('show', 'hide');
    debrisParticles.length = 0;
    breakCrackFx.length = 0;
    seaBubbles.length = 0;
    seaBubbleSpawnAcc = 0;
    deepSeaFish.length = 0;
    nextFishSpawnY = SPAWN_Y - FISH_MIN_SPAWN_OFFSET_Y;
    fishHitCooldownUntil = 0;
    jumpStretchUntil = 0;
    playerFacing = 1;
    rankSubmittedThisRound = false;
    setGameOver(false);
    if (typeof window.leaderboardRefresh === 'function') window.leaderboardRefresh();
  }

  restartBtn.addEventListener('click', resetGame);
  window.addEventListener('resize', updateWorldBounds, { passive:true });

  // ===== Loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!isGameOver){
      player.vy += GRAVITY * dt;
      player.vx *= AIR_DAMP;
      player.vy *= AIR_DAMP;

      resolve(dt);
      updateCrumblePlatforms(dt);
      updateAutoDecayPlatforms(dt);
      updateItemCollection(now);
      updateEffects(dt);
      updateSeaBubbles(dt);

      if (player.y < bestY) bestY = player.y;

      const H = viewportH || Math.round(window.innerHeight);
      const target = player.y - H * 0.40;
      cam.y = Math.min(cam.y, target);

      generatePlatformsUpTo(cam.y - H * 1.8);
      cleanupPlatforms(H);

      if (!storyShown && (hudOriginY - player.y) >= 1000){
        storyShown = true;
        showStoryToast('운이는 바다 바깥이 궁금했어요');
      }

      checkGameOver();
    }

    render();
    requestAnimationFrame(tick);
  }

  function render(){
    const W = viewportW || Math.round(window.innerWidth);
    const H = viewportH || Math.round(window.innerHeight);
    const now = performance.now();

    ctx.fillStyle = '#0b0f19';
    ctx.fillRect(0,0,W,H);
    drawSeaBubbles();

    for (const pl of platforms){
      if (pl.broken) continue;
      const sy = pl.y - cam.y;
      if (sy > H + 80 || sy + pl.h < -80) continue;

      const crumbleT = pl.crumble ? clamp(pl.standTime / CRUMBLE_BREAK_SEC, 0, 1) : 0;
      const autoDecayT = clamp((pl.decayTime - AUTO_DECAY_START_SEC) / (AUTO_DECAY_BREAK_SEC - AUTO_DECAY_START_SEC), 0, 1);
      const crackT = Math.max(crumbleT, autoDecayT);
      const cracked = pl.crumble || autoDecayT > 0;
      ctx.fillStyle = cracked
        ? (crackT > 0.7 ? '#4f2a2f' : '#3a324b')
        : '#1a2550';
      ctx.fillRect(pl.x, sy, pl.w, pl.h);

      ctx.strokeStyle = cracked ? '#8f6b6e' : '#2f46a8';
      ctx.lineWidth = 1;
      ctx.strokeRect(pl.x + 0.5, sy + 0.5, pl.w - 1, pl.h - 1);

      if (cracked){
        // 금 간 블록 표현
        ctx.strokeStyle = crackT > 0.7 ? '#d48888' : '#b39aa4';
        ctx.lineWidth = 1;
        const c1 = pl.x + pl.w * 0.22;
        const c2 = pl.x + pl.w * 0.47;
        const c3 = pl.x + pl.w * 0.71;
        ctx.beginPath();
        ctx.moveTo(c1, sy + 2); ctx.lineTo(c1 + 8, sy + pl.h - 2);
        ctx.moveTo(c2, sy + 1); ctx.lineTo(c2 - 6, sy + pl.h * 0.6); ctx.lineTo(c2 + 6, sy + pl.h - 2);
        ctx.moveTo(c3, sy + 2); ctx.lineTo(c3 - 7, sy + pl.h - 2);
        ctx.stroke();
      }

      if (pl.item){
        const itemX = pl.x + pl.w * 0.5;
        const itemY = sy - 11 + Math.sin(now * ITEM_BOB_SPEED + pl.item.phase) * ITEM_BOB_AMP;
        drawItemVisual(pl.item, itemX, itemY);
      }
    }

    drawDebrisAndCracks();

    const idleBob = isIdleAnimating()
      ? Math.sin(performance.now() * IDLE_BOB_SPEED) * IDLE_BOB_AMPLITUDE
      : 0;
    const pickupPulse = clamp((pickupPulseUntil - now) / 260, 0, 1);
    const py = player.y - cam.y + idleBob - pickupPulse * 1.2;
    if (pickupPulse > 0){
      const cx = player.x + player.w * 0.5;
      const cy = py + player.h * 0.45;
      ctx.strokeStyle = `rgba(255, 245, 168, ${0.35 * pickupPulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, 16 + (1 - pickupPulse) * 8, 0, Math.PI * 2);
      ctx.stroke();
    }
    const playerTint = getPlayerTint(now);
    drawPixelSprite(PLAYER_SPRITE_KIND, player.x, py, playerFacing, playerTint);

    if (pickupText && now < pickupTextUntil){
      const t = clamp((pickupTextUntil - now) / 1300, 0, 1);
      const alpha = t < 0.28 ? (t / 0.28) : 1;
      const tx = player.x + player.w * 0.5;
      const ty = py - 14 - (1 - t) * 12;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = '700 15px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(8, 12, 22, 0.82)';
      ctx.strokeText(pickupText, tx, ty);
      ctx.fillStyle = '#ffe9a8';
      ctx.fillText(pickupText, tx, ty);
      ctx.restore();
    } else if (pickupText && now >= pickupTextUntil){
      pickupText = '';
    }

    if (input.aiming){
      const sx = input.startX;
      const sy = input.startY;

      ctx.lineWidth = 4;
      ctx.strokeStyle = '#6aa2ff';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + input.pullX, sy + input.pullY);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#9ad1ff';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - input.pullX, sy - input.pullY);
      ctx.stroke();

      const power = clamp(Math.hypot(input.pullX, input.pullY) / MAX_PULL, 0, 1);
      ctx.fillStyle = '#6aa2ff';
      ctx.fillRect(12, 44, 140 * power, 8);
      ctx.strokeStyle = '#2f46a8';
      ctx.strokeRect(12.5, 44.5, 140, 8);
    }

    const t = elapsedSec();
    const mm = String(Math.floor(t/60)).padStart(2,'0');
    const ss = String(t%60).padStart(2,'0');

    hud.textContent =
`SCORE  ${score()}
TIME   ${mm}:${ss}
STATE  ${isGameOver ? 'GAME OVER' : (isFullyStopped() ? 'READY' : (player.onGround ? 'GROUND' : 'AIR'))}
POS    (0, ${(hudOriginY - player.y).toFixed(0)})`;
  }

  updateWorldBounds();
  seedBasePlatforms();
  loadFixedSprite();
  loadEelSprite();
  generatePlatformsUpTo(player.y - (viewportH || Math.round(window.innerHeight)) * 2.2);
  requestAnimationFrame(tick);
})();
</script>
<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  const SUPABASE_URL = "https://bemuemmhdurymuqkvfzr.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_zQDh_XUbi9EdWsWk64faRQ_OUp9bNqb";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const listEl = document.getElementById("leaderboardList");

  function esc(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  async function fetchTop10(){
    const { data, error } = await supabase
      .from("leaderboard")
      .select("name,score,created_at")
      .order("score", { ascending: false })
      .order("created_at", { ascending: true })
      .limit(5);

    if (error) {
      console.error("fetchTop10 error:", error);
      return;
    }

    listEl.innerHTML = data.map(row =>
      `<li>${esc(row.name)} — <b>${row.score}</b></li>`
    ).join("");
  }

  // 게임 시작 시 1회 로드
  fetchTop10();

  // 아래 함수들을 window에 달아두면, 기존 게임 코드에서 호출하기 편함
  window.leaderboardSubmit = async function(name, score){
    const cleanedName = String(name).trim().slice(0, 12);
    const cleanedScore = Math.max(0, Math.floor(Number(score) || 0));

    if (!cleanedName) return { ok:false, error:"name empty" };

    const { error } = await supabase
      .from("leaderboard")
      .insert([{ name: cleanedName, score: cleanedScore }]);

    if (error) {
      console.error("insert error:", error);
      return { ok:false, error: error.message || String(error) };
    }

    await fetchTop10();
    return { ok:true };
  };

  window.leaderboardRefresh = fetchTop10;
</script>
</body>
</html>
