<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>JumpKing-like Prototype (Charge Jump)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#0b0f19; overflow:hidden; }
    #wrap { position:fixed; inset:0; overflow:hidden; background:#0b0f19; }
    canvas {
      position:fixed; left:0; top:0; display:block;
      width:100vw; height:100vh;
      background:#0b0f19;
      touch-action:none;
    }
    .hud{
      position:absolute; left:12px; top:10px; color:#dbe3ff;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity:.92; user-select:none; pointer-events:none;
      white-space:pre;
    }
    .hint{
      position:absolute; left:12px; bottom:10px; color:#b9c6ff;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity:.8; user-select:none; pointer-events:none;
    }
    .overlay{
      position:absolute; inset:0; display:grid; place-items:center;
      background:rgba(6,10,20,.62);
      opacity:1; pointer-events:auto;
      display:none;
    }
    .overlay.show{ display:grid; }
    .panel{
      text-align:center; color:#f4f7ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .panel h2{
      margin:0 0 12px; font-size:44px; letter-spacing:.06em; font-weight:800;
    }
    .restart-btn{
      border:1px solid #5f84ff; background:#1d2c62; color:#e9f1ff;
      font:600 15px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding:11px 18px; border-radius:10px; cursor:pointer;
    }
    .restart-btn:hover{ background:#24397e; }
    #storyToast{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%) scale(0.98);
      max-width:min(88vw, 700px);
      padding:14px 22px;
      border-radius:14px;
      color:#f7fbff;
      font:700 clamp(22px, 4.4vw, 42px)/1.22 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      letter-spacing:-0.01em;
      text-align:center;
      white-space:normal;
      background:rgba(10, 17, 32, 0.52);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      text-shadow:0 2px 10px rgba(5, 8, 15, 0.7);
      box-shadow:0 10px 34px rgba(0, 0, 0, 0.28);
      opacity:0;
      pointer-events:none;
      z-index:30;
      transition:opacity 0.2s ease-out, transform 0.2s ease-out;
    }
    #storyToast.show{
      opacity:1;
      transform:translate(-50%, -50%) scale(1);
    }
    #storyToast.hide{
      opacity:0;
      transform:translate(-50%, -50%) scale(1.01);
      transition:opacity 0.4s ease-in, transform 0.4s ease-in;
    }
    @media (max-width: 768px){
      #leaderboard{
        top:10px !important;
        right:10px !important;
        width:170px !important;
        padding:8px !important;
        border-radius:10px !important;
        font-size:12px !important;
      }
      #leaderboardList{
        padding-left:14px !important;
        font-size:12px !important;
      }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div class="hud" id="hud"></div>
  <div class="hint">캐릭터 위에서 드래그(아래로 당길수록 강함) → 손 떼면 점프. 완전 정지해야 조작 가능.</div>
  <div id="gameOverOverlay" class="overlay">
    <div class="panel">
      <h2>GAME OVER</h2>
      <button id="restartBtn" class="restart-btn" type="button">Restart</button>
    </div>
  </div>
</div>
<div id="leaderboard" style="position:fixed; top:16px; right:16px; width:240px; padding:12px; background:rgba(0,0,0,.6); color:#fff; font-family:system-ui; border-radius:12px;">
  <div style="font-weight:700; margin-bottom:8px;">TOP 5</div>
  <ol id="leaderboardList" style="margin:0; padding-left:18px;"></ol>
</div>
<div id="storyToast" aria-live="polite"></div>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hud = document.getElementById('hud');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const storyToastEl = document.getElementById('storyToast');

  function DPR(){ return Math.max(1, Math.min(2, window.devicePixelRatio || 1)); }
  let viewportW = 0;
  let viewportH = 0;
  function resize(){
    const dpr = DPR();
    viewportW = Math.round(window.innerWidth);
    viewportH = Math.round(window.innerHeight);
    canvas.width = Math.round(viewportW * dpr);
    canvas.height = Math.round(viewportH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ===== Tuning =====
  const GRAVITY = 2200;
  const AIR_DAMP = 0.995;
  const GROUND_DAMP = 0.55;
  const STATIC_VX_EPS = 12;
  const STATIC_VY_EPS = 12;

  const MAX_PULL = 160;
  const MAX_JUMP_VY = 980;
  const MAX_JUMP_VX = 520;
  const MIN_PULL_TO_JUMP = 18;
  const MOMENTUM_MIN_POWER = 0.68;
  const MOMENTUM_IMPACT_SPEED = 260;
  const PLAYER_SPRITE_KIND = 'cat'; // 'cat' | 'dog'
  const FIXED_SPRITE_SRC = 'oon_02_sit.png';
  const IDLE_BOB_AMPLITUDE = 0.9;
  const IDLE_BOB_SPEED = 0.0046;
  const PLAYER_W = 42;
  const PLAYER_H = 56;
  const INPUT_HIT_PAD = 8;
  const JUMP_LEG_STRETCH_MS = 420;
  const JUMP_LEG_STRETCH_MAX = 19;

  const BOTTOM_OUT_MARGIN = 0;
  const SPAWN_Y = 560 - PLAYER_H;
  const PLAYFIELD_TARGET_W = 640;
  const PLAYFIELD_MIN_W = 320;
  const PLAYFIELD_SIDE_MARGIN = 24;
  const START_PLATFORM_W = 180;
  const GROUND_PAD = 260;
  const PLATFORM_SPAWN_SIDE_BLEED = 36;
  const ITEM_BOB_AMP = 2.6;
  const ITEM_BOB_SPEED = 0.0048;
  const APPLE_BUFF_MS = 10000;
  const BLUE_WEAK_MS = 10000;
  const BLUE_JUMP_SCALE = 1.45;
  const APPLE_BREAK_IMPACT = 170;
  const REACH_MAX_DY = 205;
  const CRUMBLE_BREAK_SEC = 1.7;
  const AUTO_DECAY_START_SEC = 2.2;
  const AUTO_DECAY_BREAK_SEC = 5.2;

  // ===== World =====
  const player = {
    x: 0, y: SPAWN_Y, w: PLAYER_W, h: PLAYER_H,
    vx: 0, vy: 0,
    onGround: false,
    groundPlatform: null
  };
  const cam = { y: 0 };
  let isGameOver = false;
  let frozenElapsedSec = null;
  const residualMomentum = { dirX: 0, dirY: -1, strength: 0 };
  let playerFacing = 1; // 1:right, -1:left
  let jumpStretchUntil = 0;
  let rankSubmittedThisRound = false;
  let appleBuffUntil = 0;
  let blueWeakUntil = 0;
  let pickupPulseUntil = 0;
  let pickupText = '';
  let pickupTextUntil = 0;
  let storyShown = false;
  const debrisParticles = [];
  const breakCrackFx = [];
  const spriteFxCanvas = document.createElement('canvas');
  const spriteFxCtx = spriteFxCanvas.getContext('2d');
  const STORY_TOAST_TOTAL_MS = 1600;
  const STORY_TOAST_HIDE_AT_MS = 1200;
  let storyToastHideTimer = 0;
  let storyToastEndTimer = 0;

  function clearStoryToastTimers(){
    if (storyToastHideTimer){
      clearTimeout(storyToastHideTimer);
      storyToastHideTimer = 0;
    }
    if (storyToastEndTimer){
      clearTimeout(storyToastEndTimer);
      storyToastEndTimer = 0;
    }
  }

  function showStoryToast(text){
    clearStoryToastTimers();
    storyToastEl.textContent = text;
    storyToastEl.classList.remove('show', 'hide');
    // Restart CSS transition sequence for repeated calls.
    void storyToastEl.offsetWidth;
    storyToastEl.classList.add('show');

    storyToastHideTimer = setTimeout(() => {
      storyToastEl.classList.remove('show');
      storyToastEl.classList.add('hide');
    }, STORY_TOAST_HIDE_AT_MS);

    storyToastEndTimer = setTimeout(() => {
      storyToastEl.classList.remove('hide');
    }, STORY_TOAST_TOTAL_MS);
  }

  function isFullyStopped(){
    return player.onGround && Math.abs(player.vx) < STATIC_VX_EPS && Math.abs(player.vy) < STATIC_VY_EPS;
  }

  function isIdleAnimating(){
    return !isGameOver
      && !input.aiming
      && player.onGround
      && Math.abs(player.vx) < 10
      && Math.abs(player.vy) < 10;
  }

  // ===== Platform Generation =====
  let WORLD_MIN_X = 0;
  let WORLD_MAX_X = 0;
  const platforms = [];
  let nextPlatformY = 560;
  let lastPlatformX = 120;
  let mainPlatformCount = 0;
  let lastMainSide = 0;
  let lastMainPlatform = null;
  let earlyPreferredSide = 1;
  const MAIN_MIN_DY = 90;
  const MAIN_MAX_DY = 160;
  const MAIN_MIN_SHIFT = 64;
  const MAIN_ROUTE_RETRY = 28;
  const MAIN_ROUTE_DEBUG = false;
  const MAIN_DY_DEBUG = false;
  const mainRouteRecent = [];
  const mainDyRecent = { mobile: [], desktop: [] };

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rand(min, max){ return min + Math.random() * (max - min); }
  function lerp(a,b,t){ return a + (b - a) * t; }
  function worldCenterX(){ return (WORLD_MIN_X + WORLD_MAX_X) * 0.5; }
  function isMobileMode(){
    return matchMedia("(max-width: 900px)").matches || /iPhone|Android/i.test(navigator.userAgent);
  }
  function updateWorldBounds(){
    const W = viewportW || Math.round(window.innerWidth);
    // 중앙 고정 플레이필드를 없애고 화면 전체를 플레이 영역으로 사용
    // (가운데 띠처럼 보이는 구분감을 제거)
    WORLD_MIN_X = 0;
    WORLD_MAX_X = W;
  }

  function seedBasePlatforms(){
    const playW = WORLD_MAX_X - WORLD_MIN_X;
    const startW = START_PLATFORM_W;
    const startX = clamp(worldCenterX() - startW * 0.5, WORLD_MIN_X + 24, WORLD_MAX_X - startW - 24);
    const baseW = clamp(playW * 0.62, 320, 560);
    const baseX = worldCenterX() - baseW * 0.5;

    platforms.length = 0;
    platforms.push(
      { x: baseX, y: 640, w: baseW, h: 50, keep: true, crumble: false, standTime: 0, broken: false },
      { x: startX, y: 560, w: startW, h: 16, keep: true, crumble: false, standTime: 0, broken: false }
    );

    nextPlatformY = 560;
    lastPlatformX = startX;
    mainPlatformCount = 0;
    lastMainSide = 0;
    lastMainPlatform = makePlatform(startX, 560, startW, 16, { keep: true });
    earlyPreferredSide = Math.random() < 0.5 ? -1 : 1;
    player.x = startX + (startW - player.w) * 0.5;
    player.y = SPAWN_Y;
  }

  // 발판 생성 범위를 화면 근처로 제한해서
  // 고도 상승 시 "화면은 비었는데 바깥쪽에만 발판 생성"되는 현상을 줄인다.
  function spawnMinX(){ return WORLD_MIN_X - PLATFORM_SPAWN_SIDE_BLEED; }
  function spawnMaxX(width){ return WORLD_MAX_X - width + PLATFORM_SPAWN_SIDE_BLEED; }

  function makePlatform(x, y, w, h, opts = {}){
    return {
      x, y, w, h,
      keep: !!opts.keep,
      crumble: !!opts.crumble,
      standTime: 0,
      decayTime: 0,
      broken: false,
      item: null
    };
  }

  function horizontalGapBetween(from, to){
    if (to.x > from.x + from.w) return to.x - (from.x + from.w);
    if (from.x > to.x + to.w) return from.x - (to.x + to.w);
    return 0;
  }

  function getReachMaxDx(upwardDy, difficulty){
    const t = clamp((upwardDy - 32) / (REACH_MAX_DY - 32), 0, 1);
    return lerp(330, 108, t) * lerp(1.06, 0.90, difficulty);
  }

  function getPreferredMinDx(upwardDy, difficulty){
    const base = clamp(upwardDy * 0.56, 54, 128);
    return base * lerp(1.00, 0.86, difficulty);
  }

  function isReachableFrom(from, to, difficulty){
    const upwardDy = from.y - to.y;
    if (upwardDy < 24 || upwardDy > REACH_MAX_DY) return false;
    const gapX = horizontalGapBetween(from, to);
    return gapX <= getReachMaxDx(upwardDy, difficulty);
  }

  function hasReachableAnchor(candidate, difficulty){
    for (const pl of platforms){
      if (pl.broken) continue;
      if (pl.y <= candidate.y) continue;
      const upwardDy = pl.y - candidate.y;
      if (upwardDy > REACH_MAX_DY + 16) continue;
      if (isReachableFrom(pl, candidate, difficulty)) return true;
    }
    return false;
  }

  function overlapsAnyPlatform(candidate, padding = 6){
    for (const pl of platforms){
      if (pl.broken) continue;
      if (
        candidate.x < pl.x + pl.w + padding &&
        candidate.x + candidate.w > pl.x - padding &&
        candidate.y < pl.y + pl.h + padding &&
        candidate.y + candidate.h > pl.y - padding
      ) return true;
    }
    return false;
  }

  function spawnMainPlatform(y, opts = {}){
    const anchor = lastMainPlatform;
    const center = worldCenterX();
    const climb = Math.max(0, SPAWN_Y - y);
    const difficulty = clamp(climb / 4200, 0, 1);
    const isMobile = !!opts.isMobile;
    const tuneMinDy = typeof opts.minDy === 'number' ? opts.minDy : MAIN_MIN_DY;
    const tuneMaxDy = typeof opts.maxDy === 'number' ? opts.maxDy : MAIN_MAX_DY;

    let w;
    const bucket = Math.random();
    if (bucket < 0.24) w = rand(lerp(180, 130, difficulty), lerp(250, 190, difficulty));
    else if (bucket < 0.74) w = rand(lerp(130, 92, difficulty), lerp(185, 140, difficulty));
    else w = rand(lerp(95, 68, difficulty), lerp(130, 105, difficulty));
    if (isMobile){
      const playW = WORLD_MAX_X - WORLD_MIN_X;
      w = clamp(w * rand(1.10, 1.25), 84, Math.max(150, playW * 0.58));
    }

    // 초기 anchor가 없는 경우(이론상 거의 없음) 대비
    if (!anchor){
      const x0 = clamp(center - w * 0.5 + rand(-80, 80), spawnMinX() + 2, spawnMaxX(w) - 2);
      const fallback = makePlatform(x0, y, w, 16);
      lastPlatformX = fallback.x;
      lastMainSide = (fallback.x + w * 0.5) < center ? -1 : 1;
      lastMainPlatform = makePlatform(fallback.x, fallback.y, fallback.w, fallback.h);
      mainPlatformCount += 1;
      return fallback;
    }

    const upwardDy = clamp(anchor.y - y, tuneMinDy, tuneMaxDy);
    const anchorCx = anchor.x + anchor.w * 0.5;
    const maxDxRaw = getReachMaxDx(upwardDy, difficulty);
    const maxDx = Math.max(MAIN_MIN_SHIFT + 8, maxDxRaw - 8);
    const minDxBase = getPreferredMinDx(upwardDy, difficulty);
    const minDx = clamp(Math.max(MAIN_MIN_SHIFT, minDxBase), MAIN_MIN_SHIFT, Math.max(MAIN_MIN_SHIFT + 6, maxDx - 8));
    const preferredSide = lastMainSide === 0 ? (Math.random() < 0.5 ? -1 : 1) : -lastMainSide;
    const sides = [preferredSide, -preferredSide];

    let candidate = null;
    let chosenSide = preferredSide;

    for (let tries = 0; tries < MAIN_ROUTE_RETRY; tries++){
      const side = tries < Math.floor(MAIN_ROUTE_RETRY * 0.7) ? sides[0] : sides[1];
      const dx = rand(minDx, maxDx);
      const targetCx = anchorCx + side * dx + rand(-12, 12);
      const nx = clamp(targetCx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      const c = makePlatform(nx, y, w, 16);
      const shift = Math.abs((c.x + c.w * 0.5) - anchorCx);
      if (shift < MAIN_MIN_SHIFT) continue;
      if (overlapsAnyPlatform(c, 8)) continue;
      if (!isReachableFrom(anchor, c, difficulty)) continue;
      candidate = c;
      chosenSide = side;
      break;
    }

    // 실패 시 dy/dx를 줄여서라도 반드시 도달 가능한 메인 루트 확보
    if (!candidate){
      for (let relax = 0; relax < 12 && !candidate; relax++){
        const softDy = clamp(upwardDy - relax * 6, 72, upwardDy);
        const softMaxDx = Math.max(40, getReachMaxDx(softDy, difficulty) - 6);
        const softMinDx = clamp(minDx * (0.92 - relax * 0.03), 36, softMaxDx - 4);
        const py = anchor.y - softDy;
        for (const side of sides){
          const dx = clamp(rand(softMinDx, softMaxDx), 36, softMaxDx);
          const nx = clamp(anchorCx + side * dx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
          const c = makePlatform(nx, py, w, 16);
          const shift = Math.abs((c.x + c.w * 0.5) - anchorCx);
          if (shift < 34) continue;
          if (overlapsAnyPlatform(c, 8)) continue;
          if (!isReachableFrom(anchor, c, difficulty)) continue;
          candidate = c;
          chosenSide = side;
          break;
        }
      }
    }

    // 마지막 안전장치: 반드시 통과 가능한 위치를 한 번 더 보장
    if (!candidate){
      const side = preferredSide;
      const safeDy = clamp(upwardDy, 76, 118);
      const safeMaxDx = Math.max(44, getReachMaxDx(safeDy, difficulty) - 8);
      const safeDx = clamp(Math.min(Math.max(MAIN_MIN_SHIFT, minDx), safeMaxDx - 4), 36, safeMaxDx);
      const py = anchor.y - safeDy;
      const nx = clamp(anchorCx + side * safeDx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      candidate = makePlatform(nx, py, w, 16);
      chosenSide = side;
      // 혹시 충돌이면 반대편으로 스왑
      if (overlapsAnyPlatform(candidate, 8) || !isReachableFrom(anchor, candidate, difficulty)){
        const nx2 = clamp(anchorCx - side * safeDx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
        const c2 = makePlatform(nx2, py, w, 16);
        if (!overlapsAnyPlatform(c2, 8) && isReachableFrom(anchor, c2, difficulty)){
          candidate = c2;
          chosenSide = -side;
        }
      }
    }

    if (!candidate || overlapsAnyPlatform(candidate, 8) || !isReachableFrom(anchor, candidate, difficulty)){
      let forced = null;
      for (let dyTry = 108; dyTry >= 64 && !forced; dyTry -= 6){
        const py = anchor.y - dyTry;
        const maxDxTry = Math.max(30, getReachMaxDx(dyTry, difficulty) - 4);
        const minDxTry = Math.min(Math.max(24, MAIN_MIN_SHIFT - 24), maxDxTry - 2);
        for (const side of sides){
          for (let dxTry = maxDxTry; dxTry >= minDxTry; dxTry -= 6){
            const nx = clamp(anchorCx + side * dxTry - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
            const c = makePlatform(nx, py, w, 16);
            if (overlapsAnyPlatform(c, 8)) continue;
            if (!isReachableFrom(anchor, c, difficulty)) continue;
            forced = c;
            chosenSide = side;
            break;
          }
          if (forced) break;
        }
      }
      if (forced) candidate = forced;
    }

    if (!candidate){
      const py = anchor.y - 72;
      const nx = clamp(anchorCx - w * 0.5, spawnMinX() + 2, spawnMaxX(w) - 2);
      candidate = makePlatform(nx, py, w, 16);
      chosenSide = preferredSide;
    }

    const dxLog = Math.round(Math.abs((candidate.x + candidate.w * 0.5) - anchorCx));
    const dyLog = Math.round(anchor.y - candidate.y);
    mainRouteRecent.push({ dx: dxLog, dy: dyLog, side: chosenSide });
    if (mainRouteRecent.length > 10) mainRouteRecent.shift();
    const dyMode = isMobile ? 'mobile' : 'desktop';
    const dyBucket = mainDyRecent[dyMode];
    dyBucket.push(dyLog);
    if (dyBucket.length > 10) dyBucket.shift();
    if (MAIN_ROUTE_DEBUG){
      console.log('[main-route]', mainRouteRecent.map((m) => `dx:${m.dx} dy:${m.dy} side:${m.side > 0 ? 'R' : 'L'}`).join(' | '));
    }
    if (MAIN_DY_DEBUG){
      const myAvg = dyBucket.reduce((a, b) => a + b, 0) / Math.max(1, dyBucket.length);
      const otherMode = isMobile ? 'desktop' : 'mobile';
      const otherBucket = mainDyRecent[otherMode];
      const otherAvg = otherBucket.length
        ? (otherBucket.reduce((a, b) => a + b, 0) / otherBucket.length)
        : null;
      const cmp = otherAvg === null
        ? 'n/a'
        : (myAvg > otherAvg ? 'true' : 'false');
      console.log(
        `[main-dy] mode:${dyMode} avg:${myAvg.toFixed(1)} ` +
        `${otherMode}Avg:${otherAvg === null ? 'n/a' : otherAvg.toFixed(1)} ` +
        `biggerThan${otherMode}:${cmp}`
      );
    }

    lastPlatformX = candidate.x;
    lastMainSide = chosenSide;
    lastMainPlatform = makePlatform(candidate.x, candidate.y, candidate.w, candidate.h);
    mainPlatformCount += 1;
    return candidate;
  }

  function generatePlatformsUpTo(minY){
    while (nextPlatformY > minY){
      const anchorY = lastMainPlatform ? lastMainPlatform.y : nextPlatformY;
      const climbNow = Math.max(0, SPAWN_Y - anchorY);
      const difficulty = clamp(climbNow / 4200, 0, 1);
      const earlyDense = clamp((10 - mainPlatformCount) / 10, 0, 1);
      const isMobile = isMobileMode();
      const baseMinDy = clamp(lerp(MAIN_MIN_DY, MAIN_MIN_DY + 6, difficulty), 86, MAIN_MAX_DY - 16);
      const baseMaxDy = clamp(lerp(MAIN_MAX_DY - 16, MAIN_MAX_DY, difficulty), baseMinDy + 16, MAIN_MAX_DY);

      let mainMinDy = baseMinDy;
      let mainMaxDy = baseMaxDy;
      if (isMobile){
        const minScale = lerp(1.35, 1.45, difficulty);
        const maxScale = lerp(1.50, 1.60, difficulty);
        const safeTop = REACH_MAX_DY - 8;
        mainMinDy = clamp(baseMinDy * minScale, 96, safeTop - 20);
        mainMaxDy = clamp(baseMaxDy * maxScale, mainMinDy + 12, safeTop);
      }

      let dy = rand(mainMinDy, mainMaxDy);
      // 모바일에서 gap이 너무 커져 실패할 경우를 대비한 점진 축소 fallback
      if (isMobile){
        dy = clamp(dy, mainMinDy * 0.92, REACH_MAX_DY - 8);
      }
      nextPlatformY = anchorY - dy;

      const main = spawnMainPlatform(nextPlatformY, { minDy: mainMinDy, maxDy: mainMaxDy, isMobile });
      nextPlatformY = main.y;
      if (!main.keep && mainPlatformCount > 7){
        const crumbleChance = lerp(0.11, 0.23, difficulty);
        if (Math.random() < crumbleChance) main.crumble = true;
      }
      maybeAssignItem(main, difficulty);
      platforms.push(main);

      // 고도 상승 시에도 보조 발판 확률 하한을 높여 밀도 유지
      const subChanceBase = clamp(lerp(0.40, 0.22, difficulty) + earlyDense * 0.20, 0.18, 0.62);
      const subChance = isMobile ? clamp(subChanceBase * 0.6, 0.08, 0.42) : subChanceBase;
      if (Math.random() < subChance){
        const w = rand(lerp(96, 70, difficulty), lerp(130, 105, difficulty));
        const y = nextPlatformY + rand(-18, 18);
        let x = rand(spawnMinX() + 2, spawnMaxX(w) - 2);
        const mainCenter = main.x + main.w * 0.5;
        const subCenter = x + w * 0.5;
        if (Math.abs(subCenter - mainCenter) < 200){
          x = subCenter < mainCenter
            ? clamp(main.x - rand(240, 340), spawnMinX() + 2, spawnMaxX(w) - 2)
            : clamp(main.x + rand(240, 340), spawnMinX() + 2, spawnMaxX(w) - 2);
        }
        const sub = makePlatform(x, y, w, 14, { crumble: Math.random() < 0.34 && mainPlatformCount > 7 });
        let placeable = !overlapsAnyPlatform(sub, 8);
        for (let tries = 0; tries < 10 && !placeable; tries++){
          sub.x = rand(spawnMinX() + 2, spawnMaxX(sub.w) - 2);
          placeable = !overlapsAnyPlatform(sub, 8);
        }
        if (placeable){
          maybeAssignItem(sub, difficulty);
          platforms.push(sub);
        }
      }
    }
  }

  function cleanupPlatforms(viewH){
    const cutoffY = cam.y + viewH + 1000;
    for (let i = platforms.length - 1; i >= 0; i--){
      const pl = platforms[i];
      if (pl.keep) continue;
      if (pl.broken){
        platforms.splice(i, 1);
        continue;
      }
      if (pl.y > cutoffY) platforms.splice(i, 1);
    }
  }

  function updateCrumblePlatforms(dt){
    const gp = player.onGround ? player.groundPlatform : null;
    for (const pl of platforms){
      if (!pl.crumble || pl.broken) continue;
      if (pl === gp){
        pl.standTime += dt;
        if (pl.standTime >= CRUMBLE_BREAK_SEC){
          shatterPlatform(pl);
          player.onGround = false;
          player.groundPlatform = null;
        }
      } else {
        pl.standTime = Math.max(0, pl.standTime - dt * 1.7);
      }
    }
  }

  function updateAutoDecayPlatforms(dt){
    for (const pl of platforms){
      if (pl.keep || pl.broken) continue;
      const belowPlayer = pl.y > player.y + player.h + 36;
      if (belowPlayer){
        pl.decayTime = Math.min(AUTO_DECAY_BREAK_SEC + 1.2, pl.decayTime + dt * 1.25);
        if (pl.decayTime >= AUTO_DECAY_BREAK_SEC){
          shatterPlatform(pl);
        }
      } else {
        pl.decayTime = Math.max(0, pl.decayTime - dt * 0.30);
      }
    }
  }

  function isAppleBuffActive(now = performance.now()){
    return now < appleBuffUntil;
  }

  function isBlueWeakActive(now = performance.now()){
    return now < blueWeakUntil;
  }

  function maybeAssignItem(pl, difficulty){
    if (pl.keep || pl.broken) return;
    // 초반 5~6개 메인 발판 구간에서는 아이템 비활성화
    if (mainPlatformCount <= 6) return;
    const chance = lerp(0.38, 0.28, difficulty);
    if (Math.random() > chance) return;
    const type = Math.random() < 0.5 ? 'apple' : 'blueberry';
    pl.item = { type, phase: rand(0, Math.PI * 2) };
  }

  function spawnPickupFx(x, y, color){
    pickupPulseUntil = performance.now() + 260;
    for (let i = 0; i < 10; i++){
      const a = rand(0, Math.PI * 2);
      const s = rand(85, 190);
      debrisParticles.push({
        x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s - 40,
        life: 0.32, maxLife: 0.32, size: rand(2, 4),
        color, grav: 380
      });
    }
  }

  function showPickupText(text){
    pickupText = text;
    pickupTextUntil = performance.now() + 1300;
  }

  function shatterPlatform(pl){
    if (pl.broken || pl.keep) return;
    pl.broken = true;
    breakCrackFx.push({ x: pl.x, y: pl.y, w: pl.w, h: pl.h, life: 0.16, maxLife: 0.16 });

    const pieces = Math.max(8, Math.floor(pl.w / 16));
    for (let i = 0; i < pieces; i++){
      const px = pl.x + rand(0, pl.w);
      const py = pl.y + rand(1, pl.h - 1);
      const ang = rand(-Math.PI, 0);
      const spd = rand(120, 340);
      debrisParticles.push({
        x: px, y: py,
        vx: Math.cos(ang) * spd + rand(-60, 60),
        vy: Math.sin(ang) * spd - rand(30, 120),
        life: rand(0.42, 0.7), maxLife: 0.7,
        size: rand(2, 6),
        color: pl.crumble ? '#8f6b6e' : '#5169cf',
        grav: 720
      });
    }
  }

  function updateEffects(dt){
    for (let i = debrisParticles.length - 1; i >= 0; i--){
      const p = debrisParticles[i];
      p.vy += (p.grav || 600) * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) debrisParticles.splice(i, 1);
    }
    for (let i = breakCrackFx.length - 1; i >= 0; i--){
      breakCrackFx[i].life -= dt;
      if (breakCrackFx[i].life <= 0) breakCrackFx.splice(i, 1);
    }
  }

  function updateItemCollection(now){
    const pcx = player.x + player.w * 0.5;
    const pcy = player.y + player.h * 0.5;
    for (const pl of platforms){
      if (pl.broken || !pl.item) continue;
      const itemX = pl.x + pl.w * 0.5;
      const itemY = pl.y - 11 + Math.sin(now * ITEM_BOB_SPEED + pl.item.phase) * ITEM_BOB_AMP;
      const d = Math.hypot(itemX - pcx, itemY - pcy);
      if (d > 24) continue;

      if (pl.item.type === 'apple'){
        appleBuffUntil = Math.max(appleBuffUntil, now + APPLE_BUFF_MS);
        spawnPickupFx(itemX, itemY, '#ff6b6b');
        showPickupText('운이의 힘이 굉장히 세졌습니다');
      } else {
        blueWeakUntil = Math.max(blueWeakUntil, now + BLUE_WEAK_MS);
        spawnPickupFx(itemX, itemY, '#ffd84d');
        showPickupText('운이가 자신감 있게 점프합니다');
      }
      pl.item = null;
    }
  }

  function getPlayerTint(now){
    const appleRem = appleBuffUntil - now;
    const yellowRem = blueWeakUntil - now;
    const rem = Math.max(appleRem, yellowRem);
    if (rem <= 0) return null;

    const color = appleRem >= yellowRem ? '#ff5a66' : '#ffd84d';
    let alpha = 0.36;
    if (rem <= 3000){
      const blinkOn = Math.sin(now * 0.032) > 0;
      alpha = blinkOn ? 0.34 : 0.06;
    }
    return { color, alpha };
  }

  function drawItemVisual(item, sx, sy){
    if (item.type === 'apple'){
      ctx.fillStyle = '#e84d5b';
      ctx.fillRect(sx - 5, sy - 5, 10, 10);
      ctx.fillStyle = '#ff7b86';
      ctx.fillRect(sx - 2, sy - 4, 3, 3);
      ctx.fillStyle = '#603820';
      ctx.fillRect(sx - 1, sy - 8, 2, 3);
      ctx.fillStyle = '#58b46a';
      ctx.fillRect(sx + 1, sy - 9, 3, 2);
    } else {
      ctx.fillStyle = '#f4cd38';
      ctx.fillRect(sx - 4, sy - 4, 8, 8);
      ctx.fillRect(sx - 6, sy - 2, 3, 3);
      ctx.fillRect(sx + 3, sy - 2, 3, 3);
      ctx.fillStyle = '#ffe88f';
      ctx.fillRect(sx - 1, sy - 2, 2, 2);
    }
  }

  function drawDebrisAndCracks(){
    for (const fx of breakCrackFx){
      const a = clamp(fx.life / fx.maxLife, 0, 1);
      const sy = fx.y - cam.y;
      ctx.strokeStyle = `rgba(220, 170, 170, ${0.65 * a})`;
      ctx.lineWidth = 1;
      const c1 = fx.x + fx.w * 0.2;
      const c2 = fx.x + fx.w * 0.46;
      const c3 = fx.x + fx.w * 0.72;
      ctx.beginPath();
      ctx.moveTo(c1, sy + 2); ctx.lineTo(c1 + 8, sy + fx.h - 2);
      ctx.moveTo(c2, sy + 1); ctx.lineTo(c2 - 6, sy + fx.h * 0.6); ctx.lineTo(c2 + 6, sy + fx.h - 2);
      ctx.moveTo(c3, sy + 2); ctx.lineTo(c3 - 7, sy + fx.h - 2);
      ctx.stroke();
    }

    for (const p of debrisParticles){
      const a = clamp(p.life / (p.maxLife || 1), 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color || '#9fb2ff';
      ctx.fillRect(p.x, p.y - cam.y, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  // ===== Score & Time =====
  let startY = player.y;
  let bestY = player.y;
  let t0 = performance.now();
  let hudOriginX = player.x;
  let hudOriginY = player.y;

  function score(){
    return Math.max(0, Math.floor((startY - bestY) / 10));
  }
  function elapsedSec(){
    if (frozenElapsedSec !== null) return frozenElapsedSec;
    return Math.floor((performance.now() - t0) / 1000);
  }

  // ===== Input: Charge Jump =====
  const input = {
    aiming: false,
    pid: null,
    startX: 0, startY: 0,
    curX: 0, curY: 0,
    pullX: 0, pullY: 0,
  };

  function pointerPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  const PLAYER_SPRITES = {
    cat: [
      '.1.......1...',
      '11.1...1.11..',
      '1ww1111ww11..',
      '1wwwwwwwww11.',
      '1w2www2www11.',
      '1wwwwwwwww11.',
      '.1w333333w11.',
      '.1wwwwwwww11.',
      '.1ww1ww1ww11.',
      '.1wwwwwwww11.',
      '.1ww4444ww11.',
      '.1www44www11.',
      '..11111111...',
      '..1......1...',
      '.11......11..',
      '.1........1..',
      '11........11.',
    ],
    dog: [
      '.111.....111.',
      '.1bb1...1bb1.',
      '11bbb111bbb11',
      '1bbbbbbbbbbb1',
      '1bb2bbbb2bbb1',
      '1bbbbbbbbbbb1',
      '1bbb33333bbb1',
      '.1bbbbbbbbb1.',
      '.1bbb1b1bbb1.',
      '.1bbbbbbbbb1.',
      '.1bbb444bbb1.',
      '..1bb444bb1..',
      '..111111111..',
      '..1.......1..',
      '.11.......11.',
      '.1.........1.',
      '11.........11',
    ],
  };
  const PLAYER_PALETTES = {
    cat: { '1':'#1f2f66', 'w':'#eaf1ff', '2':'#6b8cff', '3':'#ff9eb4', '4':'#d8e4ff', 'b':'#f5d7af' },
    dog: { '1':'#1f2f66', 'w':'#eaf1ff', '2':'#6b8cff', '3':'#3f3020', '4':'#f3eadb', 'b':'#deb37f' },
  };
  let fixedSpriteImg = null;
  let fixedSpriteTrim = null;
  let fixedSpriteLegColor = '#2a2f40';

  function computeOpaqueBounds(img){
    const iw = img.naturalWidth || img.width || 1;
    const ih = img.naturalHeight || img.height || 1;
    const off = document.createElement('canvas');
    off.width = iw;
    off.height = ih;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.clearRect(0, 0, iw, ih);
    octx.drawImage(img, 0, 0, iw, ih);

    const { data } = octx.getImageData(0, 0, iw, ih);
    let minX = iw, minY = ih, maxX = -1, maxY = -1;
    for (let y = 0; y < ih; y++){
      for (let x = 0; x < iw; x++){
        const a = data[(y * iw + x) * 4 + 3];
        if (a < 10) continue;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
    }

    if (maxX < minX || maxY < minY){
      return { sx: 0, sy: 0, sw: iw, sh: ih };
    }
    return { sx: minX, sy: minY, sw: (maxX - minX + 1), sh: (maxY - minY + 1) };
  }

  function computeRearLegColor(img, trim){
    const iw = img.naturalWidth || img.width || 1;
    const ih = img.naturalHeight || img.height || 1;
    const off = document.createElement('canvas');
    off.width = iw;
    off.height = ih;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.clearRect(0, 0, iw, ih);
    octx.drawImage(img, 0, 0, iw, ih);
    const { data } = octx.getImageData(0, 0, iw, ih);

    const rx0 = Math.floor(trim.sx + trim.sw * 0.00);
    const rx1 = Math.ceil(trim.sx + trim.sw * 0.45);
    const ry0 = Math.floor(trim.sy + trim.sh * 0.55);
    const ry1 = Math.ceil(trim.sy + trim.sh * 1.00);

    let r = 0, g = 0, b = 0, n = 0;
    for (let y = ry0; y < ry1; y++){
      for (let x = rx0; x < rx1; x++){
        const a = data[(y * iw + x) * 4 + 3];
        if (a < 20) continue;
        const j = (y * iw + x) * 4;
        r += data[j];
        g += data[j + 1];
        b += data[j + 2];
        n += 1;
      }
    }
    if (n === 0) return '#2a2f40';
    const rr = Math.round(r / n).toString(16).padStart(2, '0');
    const gg = Math.round(g / n).toString(16).padStart(2, '0');
    const bb = Math.round(b / n).toString(16).padStart(2, '0');
    return `#${rr}${gg}${bb}`;
  }

  function getJumpLegStretch(now){
    if (isGameOver || player.onGround) return 0;
    const launchStretch = clamp((jumpStretchUntil - now) / JUMP_LEG_STRETCH_MS, 0, 1);
    const airStretch = clamp((-player.vy - 40) / 560, 0, 1) * 0.85;
    return Math.max(launchStretch, airStretch);
  }

  function loadFixedSprite(){
    const img = new Image();
    img.onload = () => {
      fixedSpriteImg = img;
      fixedSpriteTrim = computeOpaqueBounds(img);
      fixedSpriteLegColor = computeRearLegColor(img, fixedSpriteTrim);
    };
    img.onerror = () => {
      console.warn(`[jumpking_proto] failed to load fixed sprite: ${FIXED_SPRITE_SRC}`);
    };
    img.src = FIXED_SPRITE_SRC;
  }

  function drawPixelSprite(kind, x, y, facing = 1, tint = null){
    if (fixedSpriteImg){
      const trim = fixedSpriteTrim || {
        sx: 0,
        sy: 0,
        sw: (fixedSpriteImg.naturalWidth || fixedSpriteImg.width || 1),
        sh: (fixedSpriteImg.naturalHeight || fixedSpriteImg.height || 1)
      };
      const scale = Math.min(player.w / trim.sw, player.h / trim.sh);
      const dw = trim.sw * scale;
      const dh = trim.sh * scale;
      const ox = x + (player.w - dw) * 0.5;
      const oy = y + (player.h - dh);
      const stretch = getJumpLegStretch(performance.now());
      const tw = Math.max(1, Math.round(dw));
      const th = Math.max(1, Math.round(dh));

      if (spriteFxCanvas.width !== tw || spriteFxCanvas.height !== th){
        spriteFxCanvas.width = tw;
        spriteFxCanvas.height = th;
      }
      spriteFxCtx.clearRect(0, 0, tw, th);
      spriteFxCtx.imageSmoothingEnabled = false;
      if (facing < 0){
        spriteFxCtx.save();
        spriteFxCtx.translate(tw, 0);
        spriteFxCtx.scale(-1, 1);
        spriteFxCtx.drawImage(fixedSpriteImg, trim.sx, trim.sy, trim.sw, trim.sh, 0, 0, tw, th);
        spriteFxCtx.restore();
      } else {
        spriteFxCtx.drawImage(fixedSpriteImg, trim.sx, trim.sy, trim.sw, trim.sh, 0, 0, tw, th);
      }
      if (tint){
        spriteFxCtx.globalCompositeOperation = 'source-atop';
        spriteFxCtx.globalAlpha = tint.alpha;
        spriteFxCtx.fillStyle = tint.color;
        spriteFxCtx.fillRect(0, 0, tw, th);
        spriteFxCtx.globalCompositeOperation = 'source-over';
        spriteFxCtx.globalAlpha = 1;
      }

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(spriteFxCanvas, ox, oy, dw, dh);

      if (stretch > 0.01){
        const legW = Math.max(2, Math.floor(dw * 0.09));
        const legGap = Math.max(3, Math.floor(dw * 0.12));
        const legX0 = Math.floor(dw * 0.13);
        const legY = Math.floor(dh * 0.74);
        const legH = Math.floor(6 + stretch * JUMP_LEG_STRETCH_MAX);

        ctx.fillStyle = fixedSpriteLegColor;
        if (facing < 0){
          ctx.fillRect(legX0, legY, legW, legH);
          ctx.fillRect(legX0 + legGap, legY + 1, legW, Math.max(3, legH - 1));
        } else {
          ctx.fillRect(ox + legX0, oy + legY, legW, legH);
          ctx.fillRect(ox + legX0 + legGap, oy + legY + 1, legW, Math.max(3, legH - 1));
        }
      }
      ctx.restore();
      return;
    }

    const sprite = PLAYER_SPRITES[kind] || PLAYER_SPRITES.cat;
    const palette = PLAYER_PALETTES[kind] || PLAYER_PALETTES.cat;
    const scale = Math.min(player.w / sprite[0].length, player.h / sprite.length);
    const ox = x + (player.w - sprite[0].length * scale) * 0.5;
    const oy = y + (player.h - sprite.length * scale) * 0.5;

    for (let r = 0; r < sprite.length; r++){
      const row = sprite[r];
      for (let c = 0; c < row.length; c++){
        const ch = row[c];
        if (ch === '.') continue;
        const color = palette[ch];
        if (!color) continue;
        const cc = facing < 0 ? (row.length - 1 - c) : c;
        ctx.fillStyle = color;
        ctx.fillRect(ox + cc * scale, oy + r * scale, scale, scale);
      }
    }
  }

  function playerScreenCenter(){
    return {
      x: player.x + player.w/2,
      y: (player.y - cam.y) + player.h/2
    };
  }

  function hitPlayerScreen(px, py){
    const s = { x: player.x, y: (player.y - cam.y) };
    return px >= s.x - INPUT_HIT_PAD && px <= s.x + player.w + INPUT_HIT_PAD
      && py >= s.y - INPUT_HIT_PAD && py <= s.y + player.h + INPUT_HIT_PAD;
  }

  function beginAim(e){
    if (isGameOver) return;
    if (!isFullyStopped()) return;

    const p = pointerPos(e);
    if (!hitPlayerScreen(p.x, p.y)) return;

    const c = playerScreenCenter();

    input.aiming = true;
    input.pid = e.pointerId;
    input.startX = c.x;
    input.startY = c.y;
    input.curX = p.x;
    input.curY = p.y;
    input.pullX = 0;
    input.pullY = 0;

    canvas.setPointerCapture?.(e.pointerId);
  }

  function moveAim(e){
    if (isGameOver) return;
    if (!input.aiming || e.pointerId !== input.pid) return;

    const p = pointerPos(e);
    input.curX = p.x;
    input.curY = p.y;

    let dx = input.curX - input.startX;
    let dy = input.curY - input.startY;
    dy = Math.max(0, dy);

    dx = clamp(dx, -MAX_PULL, MAX_PULL);
    dy = clamp(dy, 0, MAX_PULL);

    const dist = Math.hypot(dx, dy);
    if (dist > MAX_PULL){
      const s = MAX_PULL / dist;
      dx *= s;
      dy *= s;
    }

    input.pullX = dx;
    input.pullY = dy;
  }

  function endAim(e){
    if (isGameOver) return;
    if (!input.aiming || e.pointerId !== input.pid) return;

    const pullLen = Math.hypot(input.pullX, input.pullY);

    input.aiming = false;
    input.pid = null;

    if (pullLen < MIN_PULL_TO_JUMP) return;

    const power = clamp(pullLen / MAX_PULL, 0, 1);
    const now = performance.now();
    const jumpScale = isBlueWeakActive(now) ? BLUE_JUMP_SCALE : 1;
    const vy = -power * MAX_JUMP_VY * jumpScale;
    const vx = (input.pullX / MAX_PULL) * MAX_JUMP_VX * power * jumpScale;

    player.vx = vx;
    player.vy = vy;
    player.onGround = false;
    jumpStretchUntil = now + JUMP_LEG_STRETCH_MS;
    if (Math.abs(vx) > 8) playerFacing = Math.sign(vx);

    const n = Math.hypot(vx, vy) || 1;
    residualMomentum.dirX = vx / n;
    residualMomentum.dirY = vy / n;
    residualMomentum.strength = power;
  }

  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); beginAim(e); }, { passive:false });
  canvas.addEventListener('pointermove', (e)=>{ if(input.aiming) e.preventDefault(); moveAim(e); }, { passive:false });
  canvas.addEventListener('pointerup',   (e)=>{ e.preventDefault(); endAim(e); }, { passive:false });
  canvas.addEventListener('pointercancel',(e)=>{ endAim(e); }, { passive:true });

  // ===== Collision =====
  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function applyCollisionMomentum(blockAxis, impactSpeed){
    if (residualMomentum.strength < MOMENTUM_MIN_POWER) return false;
    if (impactSpeed < MOMENTUM_IMPACT_SPEED) return false;

    const carry = clamp((residualMomentum.strength - MOMENTUM_MIN_POWER) / (1 - MOMENTUM_MIN_POWER), 0, 1);

    if (blockAxis === 'x'){
      const tangentDir = residualMomentum.dirY !== 0
        ? Math.sign(residualMomentum.dirY)
        : (player.vy === 0 ? -1 : Math.sign(player.vy));
      const tangentGain = Math.max(80, impactSpeed * (0.16 + 0.26 * carry));
      player.vy += tangentDir * tangentGain;
      player.vx = -Math.sign(player.vx || residualMomentum.dirX || 1) * Math.min(90, impactSpeed * 0.14);
    } else {
      const tangentDir = residualMomentum.dirX !== 0
        ? Math.sign(residualMomentum.dirX)
        : (player.vx === 0 ? 0 : Math.sign(player.vx));
      const tangentGain = Math.max(70, impactSpeed * (0.20 + 0.34 * carry));
      player.vx += tangentDir * tangentGain;
      player.vy = Math.max(player.vy, 40);
    }

    residualMomentum.strength *= 0.72;
    return true;
  }

  function resolve(dt){
    player.onGround = false;
    player.groundPlatform = null;
    const prevY = player.y;

    // X move
    player.x += player.vx * dt;
    if (Math.abs(player.vx) > 18) playerFacing = Math.sign(player.vx);
    for (const pl of platforms){
      if (pl.broken) continue;
      if (!aabb(player.x, player.y, player.w, player.h, pl.x, pl.y, pl.w, pl.h)) continue;

      const impactX = Math.abs(player.vx);
      if (isAppleBuffActive() && !pl.keep && impactX > APPLE_BREAK_IMPACT){
        shatterPlatform(pl);
        continue;
      }

      // 코너 스침(세로 겹침이 매우 얕은 경우)은 옆벽 충돌로 처리하지 않는다.
      // 이걸 허용하면 "보이지 않는 벽"처럼 옆으로 밀려 착지를 놓치는 현상이 줄어든다.
      const pTop = player.y;
      const pBottom = player.y + player.h;
      const overlapY = Math.min(pBottom, pl.y + pl.h) - Math.max(pTop, pl.y);
      if (overlapY <= 6) continue;

      // 발판 윗면 착지 직전 상황은 X보다 Y 처리(착지)를 우선한다.
      const nextBottom = (player.y + player.vy * dt) + player.h;
      if (player.vy >= 0 && pBottom <= pl.y + 8 && nextBottom >= pl.y - 2) continue;

      if (player.vx > 0) player.x = pl.x - player.w;
      else if (player.vx < 0) player.x = pl.x + pl.w;
      if (!applyCollisionMomentum('x', impactX)) player.vx = 0;
    }

    // Y move
    player.y += player.vy * dt;
    for (const pl of platforms){
      if (pl.broken) continue;
      const overlapsX = player.x < pl.x + pl.w && player.x + player.w > pl.x;
      if (!overlapsX) continue;

      const prevTop = prevY;
      const prevBottom = prevY + player.h;
      const curTop = player.y;
      const curBottom = player.y + player.h;

      if (player.vy > 0){
        if (prevBottom <= pl.y && curBottom >= pl.y){
          player.y = pl.y - player.h;
          player.vy = 0;
          player.onGround = true;
          player.groundPlatform = pl;
          break;
        }
      } else if (player.vy < 0){
        const plBottom = pl.y + pl.h;
        if (prevTop >= plBottom && curTop <= plBottom){
          const impactY = Math.abs(player.vy);
          if (isAppleBuffActive() && !pl.keep && impactY > APPLE_BREAK_IMPACT){
            shatterPlatform(pl);
            continue;
          }
          player.y = plBottom;
          if (!applyCollisionMomentum('y', impactY)) player.vy = 0;
          break;
        }
      }

      if (!aabb(player.x, player.y, player.w, player.h, pl.x, pl.y, pl.w, pl.h)) continue;
      if (player.vy >= 0){
        player.y = pl.y - player.h;
        player.vy = 0;
        player.onGround = true;
        player.groundPlatform = pl;
        break;
      } else {
        const impactY = Math.abs(player.vy);
        if (isAppleBuffActive() && !pl.keep && impactY > APPLE_BREAK_IMPACT){
          shatterPlatform(pl);
          continue;
        }
        player.y = pl.y + pl.h;
        if (!applyCollisionMomentum('y', impactY)) player.vy = 0;
        break;
      }
    }

    if (player.onGround){
      player.vx *= GROUND_DAMP;
      if (Math.abs(player.vx) < STATIC_VX_EPS) player.vx = 0;
      if (Math.abs(player.vy) < STATIC_VY_EPS) player.vy = 0;
      residualMomentum.strength *= 0.88;
    } else {
      residualMomentum.strength *= 0.996;
    }
    if (residualMomentum.strength < 0.02){
      residualMomentum.strength = 0;
    }
  }

  function setGameOver(v){
    isGameOver = v;
    gameOverOverlay.classList.toggle('show', v);
    if (v){
      if (frozenElapsedSec === null) frozenElapsedSec = Math.floor((performance.now() - t0) / 1000);
      input.aiming = false;
      input.pid = null;
      submitRankOnGameOver();
    } else {
      frozenElapsedSec = null;
    }
  }

  function checkGameOver(){
    const H = viewportH || Math.round(window.innerHeight);
    const outBelow = (player.y - cam.y) > (H + BOTTOM_OUT_MARGIN);
    if (outBelow) setGameOver(true);
  }

  async function submitRankOnGameOver(){
    if (rankSubmittedThisRound) return;
    rankSubmittedThisRound = true;

    const name = prompt("이름 입력 (12자 이내)");
    if (!name) return;

    const submit = window.leaderboardSubmit;
    if (typeof submit !== 'function'){
      console.warn('leaderboardSubmit is not ready');
      alert("랭킹 모듈이 아직 준비되지 않았어요. URL/KEY 또는 네트워크를 확인해줘.");
      return;
    }

    const res = await submit(name, score());
    if (!res?.ok){
      const msg = typeof res?.error === 'string'
        ? res.error
        : (res?.error?.message || JSON.stringify(res?.error || {}));
      alert(`저장 실패: ${msg}`);
    }
  }

  function resetGame(){
    updateWorldBounds();
    seedBasePlatforms();
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    cam.y = 0;

    generatePlatformsUpTo(player.y - (viewportH || Math.round(window.innerHeight)) * 2.2);

    startY = player.y;
    bestY = player.y;
    t0 = performance.now();
    hudOriginX = player.x;
    hudOriginY = player.y;
    frozenElapsedSec = null;

    input.aiming = false;
    input.pid = null;
    residualMomentum.dirX = 0;
    residualMomentum.dirY = -1;
    residualMomentum.strength = 0;
    appleBuffUntil = 0;
    blueWeakUntil = 0;
    pickupPulseUntil = 0;
    pickupText = '';
    pickupTextUntil = 0;
    storyShown = false;
    clearStoryToastTimers();
    storyToastEl.classList.remove('show', 'hide');
    debrisParticles.length = 0;
    breakCrackFx.length = 0;
    jumpStretchUntil = 0;
    playerFacing = 1;
    rankSubmittedThisRound = false;
    setGameOver(false);
    if (typeof window.leaderboardRefresh === 'function') window.leaderboardRefresh();
  }

  restartBtn.addEventListener('click', resetGame);
  window.addEventListener('resize', updateWorldBounds, { passive:true });

  // ===== Loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!isGameOver){
      player.vy += GRAVITY * dt;
      player.vx *= AIR_DAMP;
      player.vy *= AIR_DAMP;

      resolve(dt);
      updateCrumblePlatforms(dt);
      updateAutoDecayPlatforms(dt);
      updateItemCollection(now);
      updateEffects(dt);

      if (player.y < bestY) bestY = player.y;

      const H = viewportH || Math.round(window.innerHeight);
      const target = player.y - H * 0.40;
      cam.y = Math.min(cam.y, target);

      generatePlatformsUpTo(cam.y - H * 1.8);
      cleanupPlatforms(H);

      if (!storyShown && (hudOriginY - player.y) >= 1000){
        storyShown = true;
        showStoryToast('운이는 바다 바깥이 궁금했어요');
      }

      checkGameOver();
    }

    render();
    requestAnimationFrame(tick);
  }

  function render(){
    const W = viewportW || Math.round(window.innerWidth);
    const H = viewportH || Math.round(window.innerHeight);
    const now = performance.now();

    ctx.fillStyle = '#0b0f19';
    ctx.fillRect(0,0,W,H);

    for (const pl of platforms){
      if (pl.broken) continue;
      const sy = pl.y - cam.y;
      if (sy > H + 80 || sy + pl.h < -80) continue;

      const crumbleT = pl.crumble ? clamp(pl.standTime / CRUMBLE_BREAK_SEC, 0, 1) : 0;
      const autoDecayT = clamp((pl.decayTime - AUTO_DECAY_START_SEC) / (AUTO_DECAY_BREAK_SEC - AUTO_DECAY_START_SEC), 0, 1);
      const crackT = Math.max(crumbleT, autoDecayT);
      const cracked = pl.crumble || autoDecayT > 0;
      ctx.fillStyle = cracked
        ? (crackT > 0.7 ? '#4f2a2f' : '#3a324b')
        : '#1a2550';
      ctx.fillRect(pl.x, sy, pl.w, pl.h);

      ctx.strokeStyle = cracked ? '#8f6b6e' : '#2f46a8';
      ctx.lineWidth = 1;
      ctx.strokeRect(pl.x + 0.5, sy + 0.5, pl.w - 1, pl.h - 1);

      if (cracked){
        // 금 간 블록 표현
        ctx.strokeStyle = crackT > 0.7 ? '#d48888' : '#b39aa4';
        ctx.lineWidth = 1;
        const c1 = pl.x + pl.w * 0.22;
        const c2 = pl.x + pl.w * 0.47;
        const c3 = pl.x + pl.w * 0.71;
        ctx.beginPath();
        ctx.moveTo(c1, sy + 2); ctx.lineTo(c1 + 8, sy + pl.h - 2);
        ctx.moveTo(c2, sy + 1); ctx.lineTo(c2 - 6, sy + pl.h * 0.6); ctx.lineTo(c2 + 6, sy + pl.h - 2);
        ctx.moveTo(c3, sy + 2); ctx.lineTo(c3 - 7, sy + pl.h - 2);
        ctx.stroke();
      }

      if (pl.item){
        const itemX = pl.x + pl.w * 0.5;
        const itemY = sy - 11 + Math.sin(now * ITEM_BOB_SPEED + pl.item.phase) * ITEM_BOB_AMP;
        drawItemVisual(pl.item, itemX, itemY);
      }
    }

    drawDebrisAndCracks();

    const idleBob = isIdleAnimating()
      ? Math.sin(performance.now() * IDLE_BOB_SPEED) * IDLE_BOB_AMPLITUDE
      : 0;
    const pickupPulse = clamp((pickupPulseUntil - now) / 260, 0, 1);
    const py = player.y - cam.y + idleBob - pickupPulse * 1.2;
    if (pickupPulse > 0){
      const cx = player.x + player.w * 0.5;
      const cy = py + player.h * 0.45;
      ctx.strokeStyle = `rgba(255, 245, 168, ${0.35 * pickupPulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, 16 + (1 - pickupPulse) * 8, 0, Math.PI * 2);
      ctx.stroke();
    }
    const playerTint = getPlayerTint(now);
    drawPixelSprite(PLAYER_SPRITE_KIND, player.x, py, playerFacing, playerTint);

    if (pickupText && now < pickupTextUntil){
      const t = clamp((pickupTextUntil - now) / 1300, 0, 1);
      const alpha = t < 0.28 ? (t / 0.28) : 1;
      const tx = player.x + player.w * 0.5;
      const ty = py - 14 - (1 - t) * 12;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = '700 15px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(8, 12, 22, 0.82)';
      ctx.strokeText(pickupText, tx, ty);
      ctx.fillStyle = '#ffe9a8';
      ctx.fillText(pickupText, tx, ty);
      ctx.restore();
    } else if (pickupText && now >= pickupTextUntil){
      pickupText = '';
    }

    if (input.aiming){
      const sx = input.startX;
      const sy = input.startY;

      ctx.lineWidth = 4;
      ctx.strokeStyle = '#6aa2ff';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + input.pullX, sy + input.pullY);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#9ad1ff';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - input.pullX, sy - input.pullY);
      ctx.stroke();

      const power = clamp(Math.hypot(input.pullX, input.pullY) / MAX_PULL, 0, 1);
      ctx.fillStyle = '#6aa2ff';
      ctx.fillRect(12, 44, 140 * power, 8);
      ctx.strokeStyle = '#2f46a8';
      ctx.strokeRect(12.5, 44.5, 140, 8);
    }

    const t = elapsedSec();
    const mm = String(Math.floor(t/60)).padStart(2,'0');
    const ss = String(t%60).padStart(2,'0');

    hud.textContent =
`SCORE  ${score()}
TIME   ${mm}:${ss}
STATE  ${isGameOver ? 'GAME OVER' : (isFullyStopped() ? 'READY' : (player.onGround ? 'GROUND' : 'AIR'))}
POS    (0, ${(hudOriginY - player.y).toFixed(0)})`;
  }

  updateWorldBounds();
  seedBasePlatforms();
  loadFixedSprite();
  generatePlatformsUpTo(player.y - (viewportH || Math.round(window.innerHeight)) * 2.2);
  requestAnimationFrame(tick);
})();
</script>
<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  const SUPABASE_URL = "https://bemuemmhdurymuqkvfzr.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_zQDh_XUbi9EdWsWk64faRQ_OUp9bNqb";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const listEl = document.getElementById("leaderboardList");

  function esc(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  async function fetchTop10(){
    const { data, error } = await supabase
      .from("leaderboard")
      .select("name,score,created_at")
      .order("score", { ascending: false })
      .order("created_at", { ascending: true })
      .limit(5);

    if (error) {
      console.error("fetchTop10 error:", error);
      return;
    }

    listEl.innerHTML = data.map(row =>
      `<li>${esc(row.name)} — <b>${row.score}</b></li>`
    ).join("");
  }

  // 게임 시작 시 1회 로드
  fetchTop10();

  // 아래 함수들을 window에 달아두면, 기존 게임 코드에서 호출하기 편함
  window.leaderboardSubmit = async function(name, score){
    const cleanedName = String(name).trim().slice(0, 12);
    const cleanedScore = Math.max(0, Math.floor(Number(score) || 0));

    if (!cleanedName) return { ok:false, error:"name empty" };

    const { error } = await supabase
      .from("leaderboard")
      .insert([{ name: cleanedName, score: cleanedScore }]);

    if (error) {
      console.error("insert error:", error);
      return { ok:false, error: error.message || String(error) };
    }

    await fetchTop10();
    return { ok:true };
  };

  window.leaderboardRefresh = fetchTop10;
</script>
</body>
</html>
